<?xml version="1.0" encoding="UTF-8"?><rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>ctww</title><description>blog</description><link>https://blog.haoye.plus/</link><language>en</language><item><title>Chapter 1-Physical quantities and units</title><link>https://blog.haoye.plus/posts/phy_chap1/</link><guid isPermaLink="true">https://blog.haoye.plus/posts/phy_chap1/</guid><description>A-Level Physics Chapter 1</description><pubDate>Mon, 15 Sep 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;1 Physical quantities and units&lt;/h1&gt;
&lt;p&gt;Updated on 2025-09-15&lt;/p&gt;
&lt;h2&gt;1.1 Physical quantities&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Physical quantity&lt;/strong&gt; := a quantity that can be measured and &lt;em&gt;consists of a numerical magnitude and unit&lt;/em&gt;.&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Quantity&lt;/th&gt;
&lt;th&gt;Size&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Diameter of an atom&lt;/td&gt;
&lt;td&gt;$10^{−10} \mathrm{m}$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Wavelength of UV radiation&lt;/td&gt;
&lt;td&gt;$10 \mathrm{nm}$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Height of an adult human&lt;/td&gt;
&lt;td&gt;$2 \mathrm{m}$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Distance between Earth and Sun (1 AU)&lt;/td&gt;
&lt;td&gt;$1.5 × 10^{11} \mathrm{m}$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Mass of a hydrogen atom&lt;/td&gt;
&lt;td&gt;$10^{−27} \mathrm{kg}$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Mass of an adult human&lt;/td&gt;
&lt;td&gt;$70 \mathrm{kg}$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Mass of a car&lt;/td&gt;
&lt;td&gt;$1000 \mathrm{kg}$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Seconds in a day&lt;/td&gt;
&lt;td&gt;$90 000 \mathrm{s}$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Seconds in a year&lt;/td&gt;
&lt;td&gt;$3 × 10^7 \mathrm{s}$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Speed of sound in air&lt;/td&gt;
&lt;td&gt;$300 \mathrm{ms^{−1}}$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Power of a light bulb&lt;/td&gt;
&lt;td&gt;$60 \mathrm{W}$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Atmospheric pressure&lt;/td&gt;
&lt;td&gt;$1 × 10^5 \mathrm{Pa}$&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;blockquote&gt;
&lt;p&gt;From Save My Exams&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;For AS: $g = 9.81ms^{-2}$&lt;/p&gt;
&lt;h2&gt;1.2 SI units&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Base quantities&lt;/strong&gt; are the quantities on the basis of which other quantities are expressed.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Derived quantities&lt;/strong&gt; are the quantities that are expressed in terms of base quantities.&lt;/p&gt;
&lt;p&gt;A derived quantity has an equation which links to other quantities (e.g. $F=ma$).&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Base Quantities&lt;/th&gt;
&lt;th&gt;SI Units&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Length&lt;/td&gt;
&lt;td&gt;metre ($\mathrm{m}$)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Mass&lt;/td&gt;
&lt;td&gt;kilogram ($\mathrm{kg}$)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Time&lt;/td&gt;
&lt;td&gt;second ($\mathrm{s}$)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Current&lt;/td&gt;
&lt;td&gt;Ampere ($\mathrm{A}$)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Temperature&lt;/td&gt;
&lt;td&gt;Kelvin ($\mathrm{K}$)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Amount of substance&lt;/td&gt;
&lt;td&gt;Molar ($\mathrm{mol}$)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Luminous intensity&lt;/td&gt;
&lt;td&gt;Candela ($\mathrm{cd}$)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Derived Quantities&lt;/th&gt;
&lt;th&gt;Units&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Power&lt;/td&gt;
&lt;td&gt;$\mathrm{kgm^2s^{-3}}$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Charge&lt;/td&gt;
&lt;td&gt;$\mathrm{As}$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Voltage&lt;/td&gt;
&lt;td&gt;$\mathrm{kgm^2s^{-3}A^{-1}}$&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Factor ($10^x$)&lt;/th&gt;
&lt;th&gt;Name&lt;/th&gt;
&lt;th&gt;Symbol&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;12&lt;/td&gt;
&lt;td&gt;tera&lt;/td&gt;
&lt;td&gt;T&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;9&lt;/td&gt;
&lt;td&gt;giga&lt;/td&gt;
&lt;td&gt;G&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;mega&lt;/td&gt;
&lt;td&gt;M&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;kilo&lt;/td&gt;
&lt;td&gt;k&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;-1&lt;/td&gt;
&lt;td&gt;deci&lt;/td&gt;
&lt;td&gt;d&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;-2&lt;/td&gt;
&lt;td&gt;centi&lt;/td&gt;
&lt;td&gt;c&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;-3&lt;/td&gt;
&lt;td&gt;milli&lt;/td&gt;
&lt;td&gt;m&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;-6&lt;/td&gt;
&lt;td&gt;micro&lt;/td&gt;
&lt;td&gt;μ&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;-9&lt;/td&gt;
&lt;td&gt;nano&lt;/td&gt;
&lt;td&gt;n&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;-12&lt;/td&gt;
&lt;td&gt;pico&lt;/td&gt;
&lt;td&gt;p&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;strong&gt;Homogeneity of an equation&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;An equation is &lt;strong&gt;homogeneous&lt;/strong&gt; if quantities on BOTH sides of the equation has the same unit.&lt;/p&gt;
&lt;p&gt;A homogeneous equation may not be physically correct, but a physically correct equation will always be homogeneous.&lt;/p&gt;
&lt;p&gt;:::note[question]
The speed $v$ of a liquid leaving a tube depends on the change in pressure $\Delta P$ and the density $\rho$ of the liquid. The speed is given by the equation&lt;/p&gt;
&lt;p&gt;$$
v = k(\frac{\Delta P}{\rho})^n
$$&lt;/p&gt;
&lt;p&gt;Where k is a constant that has no units&lt;/p&gt;
&lt;p&gt;What is the value of n?
:::&lt;/p&gt;
&lt;p&gt;:::tip[Significant figures]
Digits considered &lt;em&gt;significant&lt;/em&gt;: non-zero digits, zeros who:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;appearing anywhere between two non-zero digits&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;trailing zeros in a number containing a decimal point&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Digits considered &lt;em&gt;not significant&lt;/em&gt;: leading zeros, trailing zeros in a number without a decimal point
:::&lt;/p&gt;
&lt;h2&gt;1.3 Errors and uncertainties&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Random errors&lt;/strong&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;values are scattered about the true value&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;can be reduced by average&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Examples: Reading scales from different angles&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Systematic errors&lt;/strong&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;the average / peak is not the true value&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;the reading is larger or smaller than (or varying from) the true reading by a constant amount&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;can be eliminated by careful calibration&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Examples: Zero Error, Parallax Error&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Precision&lt;/strong&gt; := the range of the values / how close the result is to each other / the size of the smallest division&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;affected by random error&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;improve: repeat and average&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Accuracy&lt;/strong&gt; := how close the result is to the true value&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;affected by systematic error&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;improve: technique, accurate instrument&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;strong&gt;Uncertainty Calculation&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Absolute Uncertainty (Always 1 s.f. for the final result)&lt;/p&gt;
&lt;p&gt;$y = b \pm c \Rightarrow \Delta y = \Delta b + \Delta c$&lt;/p&gt;
&lt;p&gt;Percentage Uncertainty (1 / 2 s.f.)&lt;/p&gt;
&lt;p&gt;$
\left.
\begin{aligned}
&amp;amp;y=b\cdot c \
&amp;amp;y = \frac{b}{c}
\end{aligned}
\right}
\Rightarrow
\frac{\Delta y}{y} = \frac{\Delta b}{b} + \frac{\Delta c}{c}
$&lt;/p&gt;
&lt;p&gt;$y = a^n \Rightarrow \frac{\Delta y}{y} = n \cdot \frac{\Delta a}{a}$&lt;/p&gt;
&lt;p&gt;When the value times a &lt;em&gt;constant&lt;/em&gt;, the &lt;em&gt;absolute uncertainty&lt;/em&gt; changes but the &lt;em&gt;percentage uncertainty&lt;/em&gt; doesn&apos;t.&lt;/p&gt;
&lt;p&gt;As the s.f. of the absolute uncertainty is always one, the s.f. of the value can therefore be determined.&lt;/p&gt;
&lt;h2&gt;1.4 Scalars and Vectors*&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Scalar&lt;/th&gt;
&lt;th&gt;Vector&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;magnitude&lt;/td&gt;
&lt;td&gt;magnitude + direction&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Distance, Speed&lt;/td&gt;
&lt;td&gt;Displacement, Velocity&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;You also need to know:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;[x] Vector Addition &amp;amp; Subtraction&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;[x] Represent a vector as two perpendicular components.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Direction : N of E 30° / 30° above x-axis (math)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Remember&lt;/strong&gt; always to include a &lt;em&gt;direction&lt;/em&gt; when the result is a vector.&lt;/p&gt;
&lt;h2&gt;1.? Measurements&lt;/h2&gt;
&lt;h3&gt;Length&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Method&lt;/th&gt;
&lt;th&gt;Min / cm&lt;/th&gt;
&lt;th&gt;Max / cm&lt;/th&gt;
&lt;th&gt;Smallest Division / mm&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Measuring Tape&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;150&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Metre Rule&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;100&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Vernier Caliper&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;15&lt;/td&gt;
&lt;td&gt;0.02&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Micrometer Screw Gauge&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;2.5&lt;/td&gt;
&lt;td&gt;0.01&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;Vernier Caliper&lt;/strong&gt;(游标卡尺): main scale + vernier scale&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Micrometer Screw Gauge&lt;/strong&gt;: main scale(0.5) + fractional scale(0.01)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Remember to:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;[x] Check zero&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;[x] Repeat &amp;amp; Average&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;[x] Avoid parallax error&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Mass&lt;/h3&gt;
&lt;p&gt;balance&lt;/p&gt;
&lt;h2&gt;1.?? Uncertainties&lt;/h2&gt;
&lt;p&gt;I&apos;ve taken these notes on class but they are neither in the syllabus nor on past papers. Anyway, I put them here.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Uncertainty&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Three main types of uncertainty:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Random Uncertainties&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Systematic Errors&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Reading Uncertainties&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;The Limit of Reading&lt;/strong&gt; of a measurement is equal to the smallest graduation of the scale of an instrument.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;The Degree of Uncertainty&lt;/strong&gt; of a reading (end reading) is equal to half the smallest graduation of the scale of an instrument.&lt;/p&gt;
&lt;p&gt;Absolute - fractional errors - percentage errors&lt;/p&gt;
&lt;p&gt;1 mm - 1/208 - 0.48%&lt;/p&gt;
</content:encoded></item><item><title>Simulation of Wave Functions in Quantum Mechanics</title><link>https://blog.haoye.plus/posts/qmvis/</link><guid isPermaLink="true">https://blog.haoye.plus/posts/qmvis/</guid><description>Project of Cambridge Summer School</description><pubDate>Sat, 02 Aug 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;Simulation of Wave Functions in Quantum Mechanics&lt;/h1&gt;
&lt;p&gt;(Cambridge Summer School&apos;s Presentation)&lt;/p&gt;
&lt;p&gt;written in jupyter notebook by Yiran Feng (Leon) 2025-08-02&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Step = QMSim
Step.Gaussian = [-5, 0.5, 4]
Step.Potential = np.array([0] * 120 + [20] * 80)
%manim -qh Step
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&amp;lt;video src=&quot;https://image.haoye.plus/QMVideo/wall.mp4&quot; controls autoplay loop style=&quot;max-width: 100%;&quot;&amp;gt;
Your browser does not support the &amp;lt;code&amp;gt;video&amp;lt;/code&amp;gt; element.
&amp;lt;/video&amp;gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;Introduction&lt;/h2&gt;
&lt;p&gt;In chapter 2 and chapter 3, we&apos;ve learnt about wave function in quantum mechanics and its characteristics, however, in a rather mathematical level, with equations and deductions. In this presentation, I&apos;ll present you a python simulation of wave functions in different situations, giving you a intuitive way of understanding quantum mechanics.&lt;/p&gt;
&lt;p&gt;For simplicity, all constants are set to one in this simulation, including mass, planck&apos;s constant, etc.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# Libraries
import numpy as np
import scipy as sp
from matplotlib import pyplot as plt
from manim import *
from IPython.display import HTML
from copy import deepcopy as dc
from random import random
import tqdm

# Variables &amp;amp; Constants
inf = 100
x = np.linspace(-10, 10, 200)
y = np.linspace(-10, 10, 200)
X, Y = np.meshgrid(x, y)

# Useful functions
def find_nearest(array, value):
        array = np.asarray(array)
        idx = (np.abs(array - value)).argmin()
        return idx
    
def find_nearest_val(array, value):
        array = np.asarray(array)
        idx = (np.abs(array - value)).argmin()
        return array[idx]
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2&gt;Simulation on 1D&lt;/h2&gt;
&lt;p&gt;Basically, the simulation consists of two parts: Initialization and Evolution.&lt;/p&gt;
&lt;h3&gt;Initialization&lt;/h3&gt;
&lt;p&gt;The state of the system can be initialized with two functions: &lt;strong&gt;the initial state of the wave function&lt;/strong&gt; and &lt;strong&gt;the potential function&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;By considering different &lt;strong&gt;initial states&lt;/strong&gt; of the wave function, we can change the position, the spread, and the momentum of the particle.&lt;/p&gt;
&lt;p&gt;By changing the &lt;strong&gt;potential function&lt;/strong&gt;, we can simulate different situations, for example, harmonic oscillator and quantum channel.&lt;/p&gt;
&lt;p&gt;Look into the code. The class &lt;code&gt;Simulation1D&lt;/code&gt; takes in two variables. &lt;code&gt;phi_0&lt;/code&gt; means the initial state of the wave function, and &lt;code&gt;v&lt;/code&gt; defines the potential. The wave function is automatically normalised by the function &lt;code&gt;_normalise&lt;/code&gt;, which is called inside the initialization, and &lt;code&gt;probability&lt;/code&gt;  ( which is basically $|\phi(x)|^2$ ) gives us the probability, of course.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Simulation1D():
    def __init__(self, phi_0, v):
        self.phi = dc(phi_0); self.v = dc(v)
        self.dx = x[1] - x[0]; self.len = len(phi_0)
        self._normalise(); self._hamiltonian()
        self.prob = []; self.prob_updated = False
        
    def _normalise(self):
        self.phi /= np.linalg.norm(self.phi)
        self.prob_updated = True
        self.prob = (self.phi * self.phi.conjugate()).real
        
    def probability(self, pos = None):
        if not self.prob_updated:
            self._normalise()
        if pos:
            return self.prob[find_nearest(x, pos)]
        else:
            return self.prob
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;Evolution&lt;/h3&gt;
&lt;p&gt;From chapter 2 and chapter 3, we&apos;ve learnt that when a system is free from interactions with measuring devices, the evolution of the wave function can be calculated by the &lt;strong&gt;Schrödinger equation&lt;/strong&gt; (44) (Postulate 6)&lt;/p&gt;
&lt;p&gt;$$
i\hbar \frac{\partial ψ(x,t)}{\partial t} = \left [ -\frac{\hbar ^ 2}{2m} \frac{\partial^2}{\partial x^2} + V(x) \right ] ψ(x,t)
$$&lt;/p&gt;
&lt;p&gt;In our cases, the mass and $\hbar$ is set to 1. Introducing the hamiltonian operator $\hat H$, the &lt;strong&gt;1-dimensional time-dependent Schrödinger equation (TDSE)&lt;/strong&gt; can be deduced&lt;/p&gt;
&lt;p&gt;$$
\frac{\partial}{\partial t} ψ(x, t) = -i\hat H ψ(x, t)
$$&lt;/p&gt;
&lt;p&gt;where&lt;/p&gt;
&lt;p&gt;$$
\hat H = -\frac{1}{2} \nabla ^2 + V(x)
$$&lt;/p&gt;
&lt;p&gt;In this equation, the discrete Laplace operator can be given as convolution with &lt;strong&gt;the finite-difference kernel&lt;/strong&gt;, $[1, -2, 1]$, results in a symmetric &lt;strong&gt;Tridiagonal Toeplitz matrix&lt;/strong&gt; with the finite-difference coefficients along the diagonals. Combining this matrix with the potential $V=[V_0, V_1, ..., V_N]$, a full &lt;strong&gt;Hamiltonian operator&lt;/strong&gt; in matrix form can be obtained&lt;/p&gt;
&lt;p&gt;$$
\hat H = -\frac{1}{2\Delta x^2}
\begin{bmatrix}
-2 &amp;amp; 1 &amp;amp; \quad &amp;amp; \quad &amp;amp; \quad \
1 &amp;amp; -2 &amp;amp; 1 &amp;amp; \quad &amp;amp; \quad \
\quad &amp;amp; \quad &amp;amp; \ddots &amp;amp; \quad &amp;amp; \quad \
\quad &amp;amp; \quad &amp;amp; 1 &amp;amp; -2 &amp;amp; 1 \
\quad &amp;amp; \quad &amp;amp; \quad &amp;amp; 1 &amp;amp; -2 \
\end{bmatrix}
+
\begin{bmatrix}
V_0 &amp;amp; \quad &amp;amp; \quad &amp;amp; \quad &amp;amp; \quad \
\quad &amp;amp; V_1 &amp;amp; \quad &amp;amp; \quad &amp;amp; \quad \
\quad &amp;amp; \quad &amp;amp; \ddots &amp;amp; \quad &amp;amp; \quad \
\quad &amp;amp; \quad &amp;amp; \quad &amp;amp; V_{N-1} &amp;amp; \quad \
\quad &amp;amp; \quad &amp;amp; \quad &amp;amp; \quad &amp;amp; V_N \
\end{bmatrix}
$$&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;def _hamiltonian(self):
    &quot;&quot;&quot;Returns Hamiltonian using finite differences.&quot;&quot;&quot;
    L = [[0 for j in range(self.len)] for i in range(self.len)]
    for i in range(self.len):
        for j in range(self.len):
            if i == j:
                L[i][j] = -2
            if abs(i-j) == 1:
                L[i][j] = 1
    
    # Somehow it doesn&apos;t work...
    # L = sp.sparse.diags([1, -2, 1], offsets=[-1, 0, 1], shape=(self.len, self.len))
    
    L = np.array(L) / self.dx ** 2
    H = -L / 2 + sp.sparse.spdiags(self.v, 0, self.len, self.len)
    self.H = sp.sparse.csc_matrix(H)
    
Simulation1D._hamiltonian = _hamiltonian
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If the Hamiltonian is independent of time, a &lt;strong&gt;time evolution operator&lt;/strong&gt;(U) can be obtainted&lt;/p&gt;
&lt;p&gt;$$
ψ(t+\delta t) = Uψ(t)
$$&lt;/p&gt;
&lt;p&gt;where&lt;/p&gt;
&lt;p&gt;$$
U = e^{-i\hat H \delta t}
$$&lt;/p&gt;
&lt;p&gt;Multiplying the wave function with the operator $m$ times, we can advance the time steps to $t + m\delta t$&lt;/p&gt;
&lt;p&gt;$$
ψ(t+m\delta t) = U^mψ(t)
$$&lt;/p&gt;
&lt;p&gt;The code below calculates the time evolution operator based on the hamiltonian and &lt;code&gt;dt&lt;/code&gt;, and applies the operator to the wave function, which is also normalized after the procedure.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;def simulate(self, dt = 1e-3):
    &quot;&quot;&quot;Generates wavefunction and time at the next time step.&quot;&quot;&quot;
    U = sp.sparse.linalg.expm(-1j * self.H * dt)
    #U[1E-10 &amp;gt; (U.real**2 + U.imag**2)] = 0
    self.phi = U @ self.phi
    self.phi[self.v &amp;gt; inf-1] = 0
    self._normalise()
    
Simulation1D.simulate = simulate
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;Wave Function Representation&lt;/h3&gt;
&lt;p&gt;We use a localized Gaussian wave packet centred at $x_0$ with average initial momentum, $p_0$ , and Gaussian width, $\sigma_0$ . The wave function is given by&lt;/p&gt;
&lt;p&gt;$$
ψ(x, 0) = \left ( \frac{1}{2 \pi \sigma_0^2 } \right ) ^ \frac{1}{4} \mathrm {exp} \left ( -\frac{(x-x_0)^2}{4\sigma_0^2} + i p_0 x\right )
$$&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;def gaussian_wavepacket(x0, sigma, p0):
    &quot;&quot;&quot;Gaussian wavepacket at x0 +/- sigma, with average momentum, p0.&quot;&quot;&quot;
    global x
    return np.exp(1j*p0*x - ((x - x0)/(2 * sigma))**2)
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;Simulation&lt;/h3&gt;
&lt;p&gt;After the calculations, some simulations can be done.&lt;/p&gt;
&lt;p&gt;The class &lt;code&gt;QSim&lt;/code&gt; takes in the parameters of the gaussian wavepacket and the potential function. It produces an animation of the evolution of the wave function in 2 seconds using &lt;code&gt;manim&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class QMSim(Scene):
    def construct(self):
        phi_0 = gaussian_wavepacket(self.Gaussian[0], self.Gaussian[1], self.Gaussian[2])
        V = self.Potential
        o = Simulation1D(phi_0, V)
        
        axes = Axes(
            x_range=[-10, 10, 1],
            y_range=[0, 0.17, 1],
            x_length=10,
            axis_config={&quot;color&quot;: GREEN},
            x_axis_config={
                &quot;numbers_to_include&quot;: np.arange(-10, 10.01, 2),
                &quot;numbers_with_elongated_ticks&quot;: np.arange(-10, 10.01, 2),
            },
            tips=True,
        )
        
        axes_labels = axes.get_axis_labels()
        axes_ref = axes.copy()
        
        pot_graph = axes.plot((lambda k: (V/100)[find_nearest(x,k)]), color=BLUE)
        pot_label = axes.get_graph_label(
            pot_graph, &quot;V(x)&quot;, x_val=10, direction=UP / 2
        )
        
        prob_graph = axes.plot(o.probability, color=ORANGE)
        prob_label = axes.get_graph_label(
            prob_graph, r&quot;|\phi(x)|^2&quot;, x_val=-10, direction=UP / 2
        )

        plot = VGroup(axes, pot_graph, prob_graph)
        labels = VGroup(axes_labels, prob_label, pot_label)

        def prob_updater(mobj, dt):
            o.simulate(dt=dt*2)
            mobj.become(axes.plot(o.probability, color=ORANGE))
            return mobj
            

        prob_graph.add_updater(prob_updater)
        prob_label.add_updater(lambda x:x.become(axes.get_graph_label(prob_graph, r&quot;|\phi(x)|^2&quot;, x_val=-10, direction=UP / 2)))
        self.add(plot, labels)
        self.wait(2 + random()) # force update
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Harmonic Oscillator&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Oscillator = QMSim
Oscillator.Gaussian = [-5, 0.5, 0.1]
Oscillator.Potential = x*x
%manim -qh Oscillator
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&amp;lt;video src=&quot;https://image.haoye.plus/QMVideo/oscillator.mp4&quot; controls autoplay loop style=&quot;max-width: 100%;&quot;&amp;gt;
Your browser does not support the &amp;lt;code&amp;gt;video&amp;lt;/code&amp;gt; element.
&amp;lt;/video&amp;gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Potential Step&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Step = QMSim
Step.Gaussian = [-5, 0.5, 4]
Step.Potential = np.array([0] * 140 + [7] * 60)
%manim -qh Step
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&amp;lt;video src=&quot;https://image.haoye.plus/QMVideo/step.mp4&quot; controls autoplay loop style=&quot;max-width: 100%;&quot;&amp;gt;
Your browser does not support the &amp;lt;code&amp;gt;video&amp;lt;/code&amp;gt; element.
&amp;lt;/video&amp;gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Quantum Channel&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Channel = QMSim
Channel.Gaussian = [-5, 0.5, 4]
Channel.Potential = np.array([0] * 100 + [6] * 10 + [0] * 90)
%manim -qh Channel
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&amp;lt;video src=&quot;https://image.haoye.plus/QMVideo/channel.mp4&quot; controls autoplay loop style=&quot;max-width: 100%;&quot;&amp;gt;
Your browser does not support the &amp;lt;code&amp;gt;video&amp;lt;/code&amp;gt; element.
&amp;lt;/video&amp;gt;&lt;/p&gt;
&lt;p&gt;The real and imagery part of the wave function can also be illustrated&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class QMSim2(Scene):
    def construct(self):
        phi_0 = gaussian_wavepacket(-5, 0.4, 1.4)
        V = np.array([0] * 200)
        o = Simulation1D(phi_0, V)
        
        axes = Axes(
            x_range=[-10, 10, 1],
            y_range=[-0.3, 0.3, 1],
            x_length=10,
            axis_config={&quot;color&quot;: GREEN},
            x_axis_config={
                &quot;numbers_to_include&quot;: np.arange(-10, 10.01, 2),
                &quot;numbers_with_elongated_ticks&quot;: np.arange(-10, 10.01, 2),
            },
            tips=True,
        )
        
        axes_labels = axes.get_axis_labels()
        axes_ref = axes.copy()
        
        real_graph = axes.plot(lambda x:find_nearest_val(o.phi.real,x), color=BLUE)
        real_label = axes.get_graph_label(
            real_graph, r&quot;Re{\phi(x)}&quot;, x_val=-10, direction=UP / 2
        )
        
        imag_graph = axes.plot(lambda x:find_nearest_val(o.phi.imag,x), color=YELLOW)
        imag_label = axes.get_graph_label(
            imag_graph, r&quot;Im{\phi(x)}&quot;, x_val=10, direction=UP / 2
        )

        plot = VGroup(axes, real_graph, imag_graph)
        labels = VGroup(axes_labels, real_label, imag_label)

        def real_updater(mobj, dt):
            o.simulate(dt=dt*2)
            mobj.become(axes.plot(lambda k:(o.phi.real)[find_nearest(x,k)], color=BLUE))
            return mobj

        def imag_updater(mobj, dt):
            mobj.become(axes.plot(lambda k:(o.phi.imag)[find_nearest(x,k)], color=YELLOW))
            return mobj
            

        real_graph.add_updater(real_updater)
        imag_graph.add_updater(imag_updater)
        real_label.add_updater(lambda x:x.become(axes.get_graph_label(real_graph, r&quot;Re{\phi(x)}&quot;, x_val=-10, direction=UP / 2)))
        imag_label.add_updater(lambda x:x.become(axes.get_graph_label(imag_graph, r&quot;Im{\phi(x)}&quot;, x_val=10, direction=UP / 2)))
        
        self.add(plot, labels)
        self.wait(2 + random()) # force update
        
%manim -qh QMSim2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&amp;lt;video src=&quot;https://image.haoye.plus/QMVideo/realimag.mp4&quot; controls autoplay loop style=&quot;max-width: 100%;&quot;&amp;gt;
Your browser does not support the &amp;lt;code&amp;gt;video&amp;lt;/code&amp;gt; element.
&amp;lt;/video&amp;gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;Simulation on 2D&lt;/h2&gt;
&lt;p&gt;Applying the Schrödinger equation in 2D, we can simulate how a 2D wave function evolves.&lt;/p&gt;
&lt;p&gt;However, the calculation for 2D simulation is too complicated for my laptop to run an animation of it. Hence merely an image of the initial state of a 2D wave function is obtained in a relatively low resolution.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# Constants
x = np.linspace(-10, 10, 100)
y = np.linspace(-10, 10, 100)
X, Y = np.meshgrid(x, y)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;class Simulation2D(): # For simplicity, some code&apos;s folded up
    def __init__(self, phi_0, v):
        self.phi = dc(phi_0); self.v = dc(v)
        self.dx = x[1] - x[0]; self.dy = y[1] - y[0]
        self.lenx = len(phi_0[0]); self.leny = len(phi_0)
        self._normalise(); self._hamiltonian()
        
    def _normalise(self):
        self.phi /= np.linalg.norm(self.phi)

    def _hamiltonian(self):
        &quot;&quot;&quot;Returns Hamiltonian using finite differences.&quot;&quot;&quot;
        L1 = [[0 for j in range(self.lenx)] for i in range(self.lenx)]
        for i in range(self.lenx):
            for j in range(self.lenx):
                if i == j:
                    L1[i][j] = -2
                if abs(i-j) == 1:
                    L1[i][j] = 1
                    
        L2 = [[0 for j in range(self.leny)] for i in range(self.leny)]
        for i in range(self.leny):
            for j in range(self.leny):
                if i == j:
                    L2[i][j] = -2
                if abs(i-j) == 1:
                    L2[i][j] = 1

        # 2D Laplacian using Kronecker products
        L1 = np.array(L1) / self.dx ** 2; L2 = np.array(L2) / self.dy ** 2
        I_x = sp.sparse.identity(self.lenx); I_y = sp.sparse.identity(self.leny)
        L2D = sp.sparse.kron(I_y, L1) + sp.sparse.kron(L2, I_x)
        H = (-L2D / 2).toarray()
        for i in range(len(self.v)): # Somehow sp.sparse.diags doesn&apos;t work qaq
            H[i+i*self.lenx] = self.v[i//self.lenx][i%self.lenx]
            
        self.H = sp.sparse.csr_matrix(H)
        
    def simulate(self, dt = 1e-3):
        &quot;&quot;&quot;Generates wavefunction and time at the next time step.&quot;&quot;&quot;
        U = sp.linalg.expm(-1j * self.H.toarray() * dt)
        U[(U.real**2 + U.imag**2) &amp;lt; 1E-10] = 0
        phi_flat = self.phi.flatten()
        phi_flat = U @ phi_flat
        self.phi = phi_flat.reshape((self.lenx, self.leny))
        self.phi[self.v &amp;gt; inf-1] = 0

    def probability(self):
        return (self.phi * self.phi.conjugate()).real
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;def gaussian_wavepacket_2D(x0, y0, sigma, p0):
    &quot;&quot;&quot;Gaussian wavepacket at x0 +/- sigma, y0 +/- sigma with average momentum, p0.&quot;&quot;&quot;
    global x, y
    return np.exp(1j*p0*x - (((X - x0)**2+(Y - y0)**2)/(2 * sigma**2)))
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;def Free2D():
    phi_0 = gaussian_wavepacket_2D(3, 0, 0.5, -1)
    V = X*X+Y*Y
    o = Simulation2D(phi_0, V)
    for i in tqdm.trange(0):
        o.simulate(0.5)

    from matplotlib import cm
    from matplotlib.ticker import LinearLocator
    
    fig, ax = plt.subplots(subplot_kw={&quot;projection&quot;: &quot;3d&quot;})
    
    
    # Plot the surface.
    surf = ax.plot_surface(X, Y, o.probability(), cmap=cm.coolwarm,
                           linewidth=0, antialiased=False)
    
    # Customize the z axis.
    #ax.set_zlim(-1.01, 1.01)
    ax.zaxis.set_major_locator(LinearLocator(10))
    # A StrMethodFormatter is used automatically
    ax.zaxis.set_major_formatter(&apos;{x:.02f}&apos;)
    
    # Add a color bar which maps values to colors.
    fig.colorbar(surf, shrink=0.5, aspect=5)
    
    plt.show()
    
Free2D()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://image.haoye.plus/QMVideo/2D.png&quot; alt=&quot;png&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;Prospect&lt;/h2&gt;
&lt;p&gt;Some improvements could also be made regarding this simulation and animation ...&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Record physical quantities (momentum, energy, ...) during the simulation&lt;/li&gt;
&lt;li&gt;Increase the resolution for a higher accuracy&lt;/li&gt;
&lt;li&gt;Complete simulations in 2D&lt;/li&gt;
&lt;li&gt;...&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Thanks for listening ~&lt;/p&gt;
&lt;h2&gt;Reference&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;https://www.astro.utoronto.ca/~mahajan/notebooks/quantum_tunnelling.html&lt;/p&gt;
&lt;p&gt;https://docs.manim.community/&lt;/p&gt;
&lt;/blockquote&gt;
</content:encoded></item><item><title>IG-Maths:Extended Revision Note</title><link>https://blog.haoye.plus/posts/igcse/</link><guid isPermaLink="true">https://blog.haoye.plus/posts/igcse/</guid><description>IG Math Note</description><pubDate>Tue, 16 Apr 2024 00:00:00 GMT</pubDate><content:encoded>&lt;blockquote&gt;
&lt;p&gt;This note might not cover everything.
（有些很简单的我就没记，最好考前看一眼syllabus: &lt;a href=&quot;https://www.cambridgeinternational.org/programmes-and-qualifications/cambridge-upper-secondary/cambridge-igcse/subjects/&quot;&gt;here&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1&gt;Number&lt;/h1&gt;
&lt;h2&gt;数&lt;/h2&gt;
&lt;p&gt;Real Numbers(ℝ):实数
Integers(Whole Numbers)(ℤ):整数
Natural numbers(ℕ):自然数(不包括0？查一下syllabus)
正整数(N+)(N*)
Rational Numbers(Q):有理数
A factor: 因数
A multiple:倍数
index/order/exponents:指数
reciprocal:倒数&lt;/p&gt;
&lt;p&gt;quotient:商
Approximately equal to:约等于
identical to:全等于
bracket:括号
竖式
乘法
&lt;img src=&quot;https://cdn.savemyexams.com/cdn-cgi/image/w=1920,f=auto/uploads/2020/03/Lattice-Ex1.png&quot; alt=&quot;multiply&quot; /&gt;
除法
&lt;img src=&quot;https://cdn.savemyexams.com/cdn-cgi/image/w=1920,f=auto/uploads/2020/03/Bus-Stop-Completed-Example.png&quot; alt=&quot;division&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;集合&lt;/h2&gt;
&lt;p&gt;{(x, y) : y = 2x + 1}&lt;/p&gt;
&lt;p&gt;E:universal set&lt;/p&gt;
&lt;p&gt;∅:empty set&lt;/p&gt;
&lt;p&gt;n(∅) = 0&lt;/p&gt;
&lt;p&gt;upper case: set , lower case: element&lt;/p&gt;
&lt;p&gt;a ∈ A means a is an element of A&lt;/p&gt;
&lt;p&gt;A ⊆ B means A is a subset of B&lt;/p&gt;
&lt;p&gt;A ⊂ B means A is a proper subset of B (A≠B)&lt;/p&gt;
&lt;p&gt;A∩B intersection
A∪B union
A&apos; not A&lt;/p&gt;
&lt;h2&gt;质因数 (与最大公因数最小公倍数)&lt;/h2&gt;
&lt;p&gt;Prime tree
&lt;img src=&quot;https://cdn.savemyexams.com/cdn-cgi/image/w=1920,f=auto/uploads/2020/03/Factor-Tree-360.png&quot; alt=&quot;prime_tree&quot; /&gt;
prime factor decomposition (PFD)
indices are even: square number
indices are multiples of 3: cube number
the highest common factor (HCF)最大公因数
the lowest common multiple (LCM)最小公倍数
&lt;img src=&quot;https://cdn.savemyexams.com/cdn-cgi/image/w=1920,f=auto/uploads/2020/03/Venn-Diagram-42-90.png&quot; alt=&quot;HCF/LCM&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;指数运算&amp;amp;科学表达式&lt;/h2&gt;
&lt;p&gt;base number: 底数
index: 指数&lt;/p&gt;
&lt;p&gt;square root:平方根
cube root:立方根
A nth root
standard form: 科学表达式&lt;/p&gt;
&lt;h2&gt;分数&lt;/h2&gt;
&lt;p&gt;numerator: 分子
denominator: 分母
mixed numbers: 带分数
improper fraction(top heavy fraction): 假分数&lt;/p&gt;
&lt;h2&gt;比例&lt;/h2&gt;
&lt;p&gt;A multiplier, p, is the decimal equivalent of a percentage increase or decrease&lt;/p&gt;
&lt;h2&gt;利息&lt;/h2&gt;
&lt;p&gt;simple interest: 单利
compound interest: 复利
depreciation: 约等于复利
substitute: 代入
decay: 下降&lt;/p&gt;
&lt;h2&gt;FDP&lt;/h2&gt;
&lt;p&gt;terminating decimal: 有限小数
recurring decimal: 无限循环小数
错位相减&lt;/p&gt;
&lt;h2&gt;Ratio&lt;/h2&gt;
&lt;p&gt;direct proportion: 正比
inverse proportion: 反比&lt;/p&gt;
&lt;h2&gt;Compound Measures&lt;/h2&gt;
&lt;p&gt;没啥好说的&lt;/p&gt;
&lt;h2&gt;时间 货币 转换&lt;/h2&gt;
&lt;p&gt;millennium: 千年
midday: 12pm
midnight: 12am
am/pm : 12 1 2 3 4 5 6 7 8 9 10 11&lt;/p&gt;
&lt;p&gt;Each column represents a different bus/train – these are often called “services”&lt;/p&gt;
&lt;p&gt;The time in each cell usually indicate departure times(when the bus/train leaves that stop/station)&lt;/p&gt;
&lt;p&gt;The last location on the list usually shows the arrival time&lt;/p&gt;
&lt;p&gt;GBP: 英镑£&lt;/p&gt;
&lt;p&gt;汇率类问题单独开一行写A货币比B货币等于几比几，下面一行写x:几几几。再用除法算出scale factor&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;钱要保留两位小数！！！！&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;近似 估计 边界&lt;/h2&gt;
&lt;p&gt;estimate: 一般一个sf&lt;/p&gt;
&lt;p&gt;LB &amp;lt;= x &amp;lt; UB&lt;/p&gt;
&lt;p&gt;计算：x+-一半精度&lt;/p&gt;
&lt;h2&gt;计算器&lt;/h2&gt;
&lt;p&gt;负数：(-)
rounding 不必在计算中进行，用3.1415...省略号表示&lt;/p&gt;
&lt;h1&gt;Algebra &amp;amp; Graphs&lt;/h1&gt;
&lt;h2&gt;基础&lt;/h2&gt;
&lt;p&gt;term: 单项式
coefficient: 系数
constants: 常数
expression: 表达式
equation: 方程/等式
formula: 公式(F=ma)
inequality: 不等式
substitution: 代入
v=u+at
v2-u2=2as
s=ut+0.5at2
&quot;like&quot; terms: 同类项&lt;/p&gt;
&lt;p&gt;a^x=a^y
x=y&lt;/p&gt;
&lt;h2&gt;指数根号&lt;/h2&gt;
&lt;h2&gt;展开括号，因式分解&lt;/h2&gt;
&lt;p&gt;expanding: 展开
factorisation: 因式分解
quadratic expression: 二次表达式
monic quadratic expression: a=1
non-monic : a!=1
十字相乘
discriminant: 判别式(b2-4ac)&lt;/p&gt;
&lt;h2&gt;线性方程，不等式&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.savemyexams.com/cdn-cgi/image/f=auto,width=1920,w=1280/uploads/2022/11/2-18-solving-inequalities.png&quot; alt=&quot;number line&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;二次方程&lt;/h2&gt;
&lt;p&gt;completing the square: a(x+p)2+q
quadratic formula: 二次方程求根公式
repeated root: 两个相同的根&lt;/p&gt;
&lt;h2&gt;重整式子&lt;/h2&gt;
&lt;p&gt;(rearrange formulae)
(changing the subject)&lt;/p&gt;
&lt;h2&gt;联立方程&lt;/h2&gt;
&lt;p&gt;linear simultaneous equations: 线性方程组
Elimination: 加减消元
substitution: 代入&lt;/p&gt;
&lt;h2&gt;分式&lt;/h2&gt;
&lt;p&gt;分式: Algebraic Fractions&lt;/p&gt;
&lt;h2&gt;列方程解方程&lt;/h2&gt;
&lt;p&gt;5 lots of something: 5x
polygon: 多边形
parallelogram: 平行四边形
rhombus: 菱形
prisms: 柱体
pyramids: 锥体
regular polygon: 正多边形
interpret: 解释&lt;/p&gt;
&lt;h2&gt;函数&lt;/h2&gt;
&lt;p&gt;Composite(compound) functions: 复合函数
Inverse Functions: 反函数&lt;/p&gt;
&lt;h2&gt;数列&lt;/h2&gt;
&lt;p&gt;Sequences: 数列
term: 项
position: 索引(ish?)
position-to-term rule: 通项公式
term-to-term rule: 由an前面的项得到an
linear(arithmetic)/quadratic(二次序列)/geometric(等比序列) sequences
cubic sequence: the third differences are constant
common ratio: 公比
common difference: 公差&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;a&lt;/strong&gt; fibonacci sequence: 泛指an=a(n-1)+a(n-2)的序列，可以改变前两项
&lt;strong&gt;the&lt;/strong&gt; fibonacci sequence: 前两项为1&lt;/p&gt;
&lt;p&gt;求quadratic sequence的a: the second difference 除以二
剩下的用原数列减an2,得到一个等差数列&lt;/p&gt;
&lt;h2&gt;坐标系&lt;/h2&gt;
&lt;p&gt;steep: 陡峭的
求斜率：rise over run
Pythagoras’ Theorem: 勾股定理&lt;/p&gt;
&lt;h2&gt;线型图象&lt;/h2&gt;
&lt;p&gt;ax+by+c=0 -&amp;gt; 斜率: -a/b 截距: -c/b
parallel: 平行(相同的直线不是平行)
the negative reciprocal: 倒数取反&lt;/p&gt;
&lt;h2&gt;二次图像&lt;/h2&gt;
&lt;p&gt;parabola: 抛物线&lt;/p&gt;
&lt;h2&gt;更多图像和切线&lt;/h2&gt;
&lt;h2&gt;解不等式&lt;/h2&gt;
&lt;p&gt;有等号的用实线，否则用虚线
要shade unwanted的area&lt;/p&gt;
&lt;h2&gt;生活中的图像&lt;/h2&gt;
&lt;p&gt;conversion/convert: 转换
deceleration: 减速&lt;/p&gt;
&lt;h2&gt;微分&lt;/h2&gt;
&lt;p&gt;the derivative: 导数
the derived function: 导函数
f&apos;(x) -&amp;gt; f-dashed-of-x
Turning points/stationary points: 导数为0的点
peak/trough: 峰/谷
positive cubic: 左边最大值，右边最小值
negative cubic: 左边最小值，右边最大值
d2y/dx2
optimisation/optimal: 优化&lt;/p&gt;
&lt;h1&gt;Geometry&lt;/h1&gt;
&lt;h2&gt;基本&lt;/h2&gt;
&lt;p&gt;symmetry: 对称
the order of rotational symmetry: 转一圈有几次和自己一样
(有的时候order是1也会说成没有rotational symmetry)
n lines of symmetry(有n条对称轴)
mirror line
polygon: 多边形
cuboid: 长方体
cylinder: 圆柱&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;triangle&lt;/li&gt;
&lt;li&gt;quadrilateral&lt;/li&gt;
&lt;li&gt;pentagon&lt;/li&gt;
&lt;li&gt;hexagon&lt;/li&gt;
&lt;li&gt;heptagon&lt;/li&gt;
&lt;li&gt;octagon&lt;/li&gt;
&lt;li&gt;nonagon&lt;/li&gt;
&lt;li&gt;decagon&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;cube: 9 planes of symmetry
一般来说，柱体的planes of symmetry是横截面的对称轴数量加1
而锥体的是横截面对称轴数量
equilateral triangle: 等边三角形
isosceles triangle: 等腰三角形
parallelograms: 平行四边形
rhombuses(rhombi): 菱形
trapezium: 梯形（一对边平行）
kite: 两组邻边相等的四边形
bisect: 平分
obtuse angle: 钝角
acute angle: 锐角
dagonal: 对角线
perimeter: 周长
circumference: 圆的周长
&lt;img src=&quot;https://cdn.savemyexams.com/cdn-cgi/image/f=auto,width=1920,w=1280/uploads/2020/03/Parts-of-a-circle.png&quot; alt=&quot;circle&quot; /&gt;&lt;/p&gt;
&lt;p&gt;prism: 柱体
pyramid: 锥体
square-based pyramid
cone: circular base
tetrahedron: base is an equilateral triangle&lt;/p&gt;
&lt;p&gt;face/vertex(vertices)/edge&lt;/p&gt;
&lt;p&gt;net: 展开图&lt;/p&gt;
&lt;p&gt;1cl = 10 ml&lt;/p&gt;
&lt;p&gt;1 hectare (ha) = 10 000 m2&lt;/p&gt;
&lt;h2&gt;多边形和平行线里的角&lt;/h2&gt;
&lt;p&gt;basic angle properties:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Angles that meet at a point add up to 360°&lt;/li&gt;
&lt;li&gt;Angles that meet at a point on a straight line add up to 180°&lt;/li&gt;
&lt;li&gt;Vertically opposite angles are equal(对顶角相等)
regular polygon: 正多边形&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;sum of interior angles = 180° × (n-2)
外角(exterior angle)和永远为360°&lt;/p&gt;
&lt;p&gt;Corresponding angles are equal(同位角相等)
Alternate angles are equal(内错角相等)
Allied (co-interior) angles add to 180°(同旁内角互补)
(on parallel lines)&lt;/p&gt;
&lt;p&gt;transverse: 跨过两个平行线的直线&lt;/p&gt;
&lt;h2&gt;bearings constructions &amp;amp; scale drawings&lt;/h2&gt;
&lt;p&gt;bearing: 从北方开始顺时针测量，保留三位有效数字，不写degree symbol
(画图记得画north line)
面积用A(Area)&lt;/p&gt;
&lt;h2&gt;圆&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;所有的circle theorem在考试中都要写出来&lt;/strong&gt;
Circle Theorem: The angle subtended by an arc at the centre is twice the angle at the circumference(这个定理必须写出来)
Circle Theorem: The angle in a semicircle is a right angle(俺也一样)&lt;/p&gt;
&lt;p&gt;chord(弦)
Any equal chords are equidistant from the centre of the circle
Circle Theorem: The perpendicular bisector of a chord is a radius
Circle Theorem: A radius and a tangent meet at right angles
Two tangents from a circle to the same point outside of a circle are equal&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;cyclic quadrilaterals&lt;/strong&gt;(圆内接四边形)
Circle theorem: Opposite angles in a cyclic quadrilateral add up to 180°&lt;/p&gt;
&lt;p&gt;Circle Theorem: Angles at the circumference subtended by the same arc are equal(Angles in the same segment are equal)
Circle Theorem: Alternate Segment Theorem(弦切角定理)
&lt;img src=&quot;https://cdn.savemyexams.com/cdn-cgi/image/w=1920,f=auto/uploads/2020/03/Alternate-Segment-Theorem.png&quot; alt=&quot;circle theorem&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;面积和周长&lt;/h2&gt;
&lt;p&gt;compound shapes: 由多个简单图形拼接出来的图形
rectangle: A=lw
triangle: A=1/2 bh
trapezium: A=1/2 (a+b)h
parallelogram: A=bh&lt;/p&gt;
&lt;h2&gt;圆和扇形和弧&lt;/h2&gt;
&lt;p&gt;arc:弧
minor arc(劣弧)
major arc(优弧)
sector: 扇形
minor sector
major sector&lt;/p&gt;
&lt;h2&gt;体积和表面积&lt;/h2&gt;
&lt;p&gt;volume: 体积
volume of a pyramid: 三分之一底乘高
圆的体积：4/3 πr3
frustum: 圆台&lt;/p&gt;
&lt;p&gt;surface area: 表面积
slant height: 斜高
surface area of a sphere = 4πr2&lt;/p&gt;
&lt;h2&gt;全等和相似(congruence &amp;amp; similarity)&lt;/h2&gt;
&lt;p&gt;congruent/congruence: 全等
SAS,ASA,AAS,SSS,RHS
similar: 相似
证明任意多边形相似：对应边成比例
三角形：AAA
Equivalent: 对应的&lt;/p&gt;
&lt;h2&gt;直角三角形&lt;/h2&gt;
&lt;p&gt;Pythagoras’ Theorem: 勾股定理
hypotenuse: 斜边
opposite: 对边
Adjacent: 邻边&lt;/p&gt;
&lt;p&gt;Trigonometry: 三角学
sin: 奇函数
cos: 偶函数&lt;/p&gt;
&lt;p&gt;the angles of elevation and depression
&lt;img src=&quot;https://cdn.savemyexams.com/cdn-cgi/image/f=auto,width=1920,w=1280/uploads/2023/06/IV60s58R_ib-ai-sl-3-3-3-applications-of-trigonometry-diagram-1.png&quot; alt=&quot;graph&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;sine, cosine rule &amp;amp; 三角形面积&lt;/h2&gt;
&lt;p&gt;the sine rule: a/sinA = b/sinB = c/sinC
the cosine rule: cosA = (b2+c2-a2) / 2bc
or a2=b2+c2 - 2bc cosA&lt;/p&gt;
&lt;p&gt;A = 1/2 ab sinC
表示角的方法: ABC上面加一个^&lt;/p&gt;
&lt;h2&gt;三维三角函数&lt;/h2&gt;
&lt;p&gt;d2=a2+b2+c2&lt;/p&gt;
&lt;h2&gt;三角函数图像和方程&lt;/h2&gt;
&lt;p&gt;先label出关键点，再连接成线
&lt;img src=&quot;https://cdn.savemyexams.com/cdn-cgi/image/f=auto,width=1920,w=1280/uploads/2022/10/cie-igcse-3-12-2-solving-trig-equations-4.png&quot; alt=&quot;graph&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;向量&lt;/h2&gt;
&lt;p&gt;magnitude direction
translation vector
scalar: 标量
magnitude(modulus): |&lt;strong&gt;a&lt;/strong&gt;|
specific vector: AB-&amp;gt;
general vector: &lt;strong&gt;a&lt;/strong&gt;
证明三点共线：找出两个向量平行&lt;/p&gt;
&lt;h2&gt;变化&lt;/h2&gt;
&lt;p&gt;original shape: object(A,B,C)
transformed shape: image(A&apos;,B&apos;,C&apos;)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;translation&lt;/strong&gt;
Shape A has been translated using the vector (一个向量)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;reflection&lt;/strong&gt;
&lt;img src=&quot;https://cdn.savemyexams.com/cdn-cgi/image/w=1280,f=auto/uploads/2020/03/Q1-Reflection-Solution.png&quot; alt=&quot;reflection&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Shape A has been reflected in the line x=-1 to create shape B&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;rotation&lt;/strong&gt;
Rotation, 90o clockwise with centre (-4, 0)
&lt;strong&gt;enlargement&lt;/strong&gt;
The length scale factor is 2, therefore the area scale factor will be 2^2 = 4, hence, the area of C&apos; is 4 times larger than C&lt;/p&gt;
&lt;p&gt;Shape A has been enlarged using a scale factor of 3 and a centre of enlargement (9, 9) to create shape B&lt;/p&gt;
&lt;p&gt;C.o.E&lt;/p&gt;
&lt;p&gt;&lt;s&gt;objection&lt;/s&gt;&lt;/p&gt;
&lt;h1&gt;Probability &amp;amp; Statistics&lt;/h1&gt;
&lt;h2&gt;基础&lt;/h2&gt;
&lt;p&gt;An experiment is a repeatable activity that has a result that can be observed or recorded
Trials are what we call the repeats of the experiment
An outcome is a possible result of a trial
An event is an outcome or a collection of outcomes
A sample space is the set of all possible outcomes of an experiment
The probability of event A is denoted as P(A)&lt;/p&gt;
&lt;p&gt;The complement of event A is the event where event A does not happen
A&apos;
mutually exclusive events: 发生了A就不可能发生B，A交B为空集&lt;/p&gt;
&lt;p&gt;sample space: 所有可能的结果
possibility diagram: combining two things using a grid
&lt;img src=&quot;https://cdn.savemyexams.com/cdn-cgi/image/f=auto,width=1920,w=1280/uploads/2022/12/dice-grid.png&quot; alt=&quot;possibility diagram&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Relative frequency(estimate probabilities from experimental data)&lt;/p&gt;
&lt;p&gt;expected frequency(the number of times you would expect a particular outcome to occur when repeating a trial numerous times)&lt;/p&gt;
&lt;h2&gt;概率图像&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Two Way Tables&lt;/strong&gt;
The row/column totals are sometimes called marginal (or sub-) totals
Where the row totals and column totals meet, we have the grand total
Conditional probabilities are sometimes written using the &apos;straight bar&apos; notation P(A|B)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Venn Diagrams&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Tree Diagrams&lt;/strong&gt;
&lt;img src=&quot;https://cdn.savemyexams.com/cdn-cgi/image/f=auto,width=1920,w=1280/uploads/2022/05/3-1-3-fig1-tree-setup.png&quot; alt=&quot;tree&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;conditional probability&lt;/h2&gt;
&lt;h2&gt;平均和极差&lt;/h2&gt;
&lt;h2&gt;统计图像&lt;/h2&gt;
&lt;h2&gt;Histogram(直方图)&lt;/h2&gt;
&lt;h2&gt;cumulative frequency &amp;amp; box plots&lt;/h2&gt;
&lt;p&gt;Correlation is a way of describing the way two quantities are related to each other&lt;/p&gt;
&lt;p&gt;positive/negative/no coorelation&lt;/p&gt;
&lt;p&gt;correlation doesn&apos;t mean causation&lt;/p&gt;
&lt;h2&gt;scatter graphs &amp;amp; correlation&lt;/h2&gt;
&lt;h1&gt;Some own experience&lt;/h1&gt;
&lt;p&gt;记得带量角器
多于一分记得写过程
show all your working: 每一步都要写(假分数变带分数的过程也要)
degree 保留一个小数位
有一些题目不需要3sf，直接写出答案
圆切角定理！！！&lt;/p&gt;
&lt;p&gt;Arno buys a student ticket for $43.68 .
This is a saving of 16% on the full price of a ticket.
Calculate the full price of a ticket.&lt;/p&gt;
&lt;p&gt;43.68是减去16%后的价格，并不是那16%&lt;/p&gt;
&lt;p&gt;看清题目要求increase还是自己&lt;/p&gt;
&lt;p&gt;Reference: &lt;a href=&quot;https://www.savemyexams.com/&quot;&gt;savemyexams&lt;/a&gt;&lt;/p&gt;
</content:encoded></item><item><title>AC自动机(Aho-Corasick Algorithm)</title><link>https://blog.haoye.plus/posts/ac/</link><guid isPermaLink="true">https://blog.haoye.plus/posts/ac/</guid><description>AC Algorithm</description><pubDate>Sun, 19 Nov 2023 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;&lt;s&gt;自动AC机&lt;/s&gt;&lt;/p&gt;
&lt;p&gt;前置知识：kmp算法&lt;/p&gt;
&lt;p&gt;beta版本，还没加图片qwq（不过也能看）&lt;/p&gt;
&lt;h1&gt;引入&lt;/h1&gt;
&lt;p&gt;kmp算法处理了一个模式串在一个文本串中匹配的场景。如果是多个模式串在一个文本串匹配呢？&lt;/p&gt;
&lt;h1&gt;Trie树&lt;/h1&gt;
&lt;p&gt;由于我们在&lt;a href=&quot;https://blog.haoye.plus/post/trie&quot;&gt;上一章&lt;/a&gt;详细讨论了字典树，这章就不做赘述&lt;/p&gt;
&lt;h1&gt;Fail指针&lt;/h1&gt;
&lt;p&gt;如同kmp算法一样，AC自动机高效的原因也是&lt;strong&gt;在失配的时候可以及时调整，避免重复运算&lt;/strong&gt;，用一个 &lt;code&gt;fail&lt;/code&gt; 数组实现这一流程。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;fail[i]&lt;/code&gt; 所储存的值 &lt;code&gt;u&lt;/code&gt; 是存在于字典树中的 &lt;code&gt;i&lt;/code&gt; 的最长后缀。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;fail[i]&lt;/code&gt; 的值可以由比点 &lt;code&gt;i&lt;/code&gt; 辈分还高的点的 &lt;code&gt;fail&lt;/code&gt; 值得到。我们先来看一下过程&lt;/p&gt;
&lt;p&gt;考虑计算 &lt;code&gt;fail[i]&lt;/code&gt; 的值：&lt;/p&gt;
&lt;p&gt;让 &lt;code&gt;u = fa[i]&lt;/code&gt;，也就是i的父节点&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;如果 &lt;code&gt;fail[u]&lt;/code&gt; 的子节点中有 &lt;code&gt;i&lt;/code&gt; 的值，那么 &lt;code&gt;fail[i] = fail[u]的那个子节点&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;如果 &lt;code&gt;fail[u]&lt;/code&gt; 的子节点中没有 &lt;code&gt;i&lt;/code&gt; 的值，那么 &lt;code&gt;u = fail[u]&lt;/code&gt; ，从头继续&lt;/li&gt;
&lt;li&gt;如果 &lt;code&gt;u&lt;/code&gt; 已经是根节点了，那么停止循环， &lt;code&gt;fail[u] = 0&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;为什么这样可行呢？&lt;/p&gt;
&lt;p&gt;因为 &lt;code&gt;i&lt;/code&gt; 的父节点已经帮 &lt;code&gt;i&lt;/code&gt; 找好了 &lt;code&gt;i&lt;/code&gt; 前一个字符串的最长公共后缀的元素在哪里。对于 &lt;code&gt;i&lt;/code&gt; 来说，只要“子承父业”，继承父亲所找到的那个元素就好了，如果“父业”（也就是 &lt;code&gt;fail[fa[i]]&lt;/code&gt; 节点）下有他儿子就好。（对应步骤1）&lt;/p&gt;
&lt;p&gt;如果没有也没关系。继承不了父亲的也可以沿着父亲找到的那个元素的链条往上爬，再往上找，直到找到某个元素使这个元素的子节点下面有 &lt;code&gt;i&lt;/code&gt; 就行。（对应步骤2）如果实在没有直接 &lt;code&gt;fail[i] = 0&lt;/code&gt;（对应步骤3）&lt;/p&gt;
&lt;h1&gt;Fail 指针优化&lt;/h1&gt;
&lt;p&gt;看起来很美好，可是如果一直向上追溯肯定时间不够。&lt;/p&gt;
&lt;p&gt;我们可以给每个元素都加上“虚拟儿子”，凑齐二十六个字母（如果题目有数字那也要包括）。这样子元素就可以直接“子承父业”， &lt;code&gt;fail[i] = fail[fa[i]].son[i对应的字符的值]&lt;/code&gt;（不用上一节一直往上爬（步骤2）了，因为“父业”下面已经有这个儿子了~~（虽然可能是虚拟的）~~）。i的“虚拟儿子” &lt;code&gt;c&lt;/code&gt; （也就是 &lt;code&gt;i&lt;/code&gt; 原本没有 &lt;code&gt;c&lt;/code&gt; 这个儿子）是&lt;code&gt;i.son[c] = fail[i].son[c]&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;前面一句话好理解。那么最后一句话呢？&lt;/p&gt;
&lt;p&gt;其实“虚拟儿子”就保存着我们上一节循环后的答案。这里“真实儿子”对应着步骤1找到了元素，“虚拟儿子”对应着步骤2没找到元素。因为 &lt;code&gt;i&lt;/code&gt; 的虚拟儿子 &lt;code&gt;c&lt;/code&gt; 是由  &lt;code&gt;fail[i]&lt;/code&gt; 的儿子 &lt;code&gt;c&lt;/code&gt; 得到的。如果它是真实的那么最终 &lt;code&gt;i&lt;/code&gt; 的虚拟儿子 &lt;code&gt;c&lt;/code&gt; 就对应着另一个元素 &lt;code&gt;fail[fa[d]] = i,d的值为c&lt;/code&gt; 的 &lt;code&gt;fail[d]&lt;/code&gt; 的值，&lt;code&gt;fail[d] = i.son[c]&lt;/code&gt;。即使它是虚拟的但他也是由&lt;code&gt;fail[fail[i]]&lt;/code&gt; 的儿子 &lt;code&gt;c&lt;/code&gt; 得到的。一直向上，和上一节的循环一样。如果遇到了真实的停，直到根节点。只不过是把这个过程&lt;strong&gt;从上往下&lt;/strong&gt;进行了而已。&lt;/p&gt;
&lt;p&gt;用&lt;strong&gt;BFS&lt;/strong&gt;（广度优先搜索）从上往下更新，可以保证更新一个节点时比它辈分还大的节点已经更新完了。&lt;/p&gt;
&lt;p&gt;引用一句名言&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Talk is cheap. Show me the code.&lt;/p&gt;
&lt;p&gt;​                                               --- Linus&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;queue&amp;lt;int&amp;gt; que;
void bfs(){
    for(int i=0;i&amp;lt;=25;i++){
        if(tr[0][i])que.push(tr[0][i]);
    }
    while(!que.empty()){
        int u=que.front();
        que.pop();
        for(int i=0;i&amp;lt;=25;i++){
            if(!tr[u][i])   tr[u][i]=tr[fail[u]][i];//创建虚拟儿子
            else{//更新fail指针
                que.push(tr[u][i]);
                fail[tr[u][i]]=tr[fail[u]][i];
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1&gt;查询&lt;/h1&gt;
&lt;p&gt;运用虚拟儿子解决了匹配失败的问题。那么匹配成功走真的儿子，匹配失败走假的儿子，就可以忽略这一差别，直接向下走。我们上一章讲了在字符串末尾打上标记，查询的时候就可以直接向下走，然后记录遇到了几个标记，并且把他清零（如果只需要匹配一次的话）。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;void find(string s){
    int u=0,c;
    for(int i=0;i&amp;lt;s.length();i++){
        c=s[i]-&apos;a&apos;;
        u=tr[u][c];//向下走一步
        ans+=bo[u];
        bo[u]=0;//确保同一字符串只被统计一次
    }
    return;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1&gt;代码实践&lt;/h1&gt;
&lt;p&gt;洛谷：&lt;a href=&quot;https://www.luogu.com.cn/problem/P3808&quot;&gt;P3808&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include&amp;lt;iostream&amp;gt;
#include&amp;lt;string&amp;gt;
#include&amp;lt;queue&amp;gt;

using namespace std;

#define N 1000009

int n;
int ans,cnt;
int fail[N];
int tr[N][30];
int bo[N];
 
void make(string s){
    int u=0;
    for(int i=0;i&amp;lt;s.length();++i){
        int c=s[i]-&apos;a&apos;;
        if(!tr[u][c]){
            tr[u][c]=++cnt;
        }
        u=tr[u][c];
    }
    bo[u]++;
    return;
}

queue&amp;lt;int&amp;gt; que;
void bfs(){
    for(int i=0;i&amp;lt;=25;i++){
        if(tr[0][i])que.push(tr[0][i]);
    }
    while(!que.empty()){
        int u=que.front();
        que.pop();
        for(int i=0;i&amp;lt;=25;i++){
            if(!tr[u][i])   tr[u][i]=tr[fail[u]][i];//创建虚拟儿子
            else{//更新fail指针
                que.push(tr[u][i]);
                fail[tr[u][i]]=tr[fail[u]][i];
            }
        }
    }
}

void find(string s){
    int u=0,c;
    for(int i=0;i&amp;lt;s.length();i++){
        c=s[i]-&apos;a&apos;;
        u=tr[u][c];
        ans+=bo[u];
        bo[u]=0;//确保同一字符串只被统计一次
    }
    return;
}

int main(){
    int n;
    string s;
    ans=0;cnt=0;

    cin&amp;gt;&amp;gt;n;

    //输入模式串
    while(n--){
        cin&amp;gt;&amp;gt;s;
        //建立trie树
        make(s);
    }

    //建立next指针
    bfs();
    
    //输入文本串
    cin&amp;gt;&amp;gt;s;
    //ac自动机
    find(s);

    cout&amp;lt;&amp;lt;ans&amp;lt;&amp;lt;endl;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
</content:encoded></item><item><title>字典树(Trie)</title><link>https://blog.haoye.plus/posts/trie/</link><guid isPermaLink="true">https://blog.haoye.plus/posts/trie/</guid><description>Trie</description><pubDate>Sat, 18 Nov 2023 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;AC自动机的前置知识（=^^）/&lt;/p&gt;
&lt;h1&gt;问题&lt;/h1&gt;
&lt;p&gt;给定很多个文本串 &lt;code&gt;t[i]&lt;/code&gt; 和很多个模式串 &lt;code&gt;s[i]&lt;/code&gt; 。怎样算出每个文本串是多少个模式串的前缀？&lt;/p&gt;
&lt;h1&gt;字典树~削弱版~&lt;/h1&gt;
&lt;p&gt;我们一个一个匹配显然太慢了。有没有什么方法可以简化这个流程呢？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://image.haoye.plus/Screenshot%20from%202023-11-18%2019-47-15.png&quot; alt=&quot;美丽的Trie图&quot; /&gt;&lt;/p&gt;
&lt;p&gt;这就是，，，，&lt;strong&gt;字典树&lt;/strong&gt;！！&lt;/p&gt;
&lt;p&gt;可以从上面的图片看到，对于多个字符串，如果把他们的公共前缀合在一起，最终得到的结果类似于一个树。这样具有公共前缀的不同字符串只用枚举一次就可以了！！！（这就是为什么它也叫&lt;strong&gt;前缀树&lt;/strong&gt;）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;不过&lt;/strong&gt;，这张图片还有点不完美。我们并不知道有几个模式串有这个前缀。可以在字典树的每个节点加一个数据 &lt;code&gt;num[i]&lt;/code&gt;（在图片右下角），记录拥有这个公共前缀的字符串的个数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;再&lt;/strong&gt;给每个字符串的末尾打上标记后（虽然对于上面的问题来说这个步骤不重要，但是看到下一章的AC自动机（&lt;s&gt;自动AC机&lt;/s&gt;）来说，这个就重要了），我们就得到了一个比较完美的字典树。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://image.haoye.plus/Screenshot%20from%202023-11-18%2019-46-55.png&quot; alt=&quot;高级智慧炫酷充满力量的最终版本字典树&quot; /&gt;&lt;/p&gt;
&lt;p&gt;可我们还没有考虑一种情况。&lt;/p&gt;
&lt;h1&gt;字典树&lt;/h1&gt;
&lt;p&gt;有没有发现，上一节这些字符串们的第一个字符都是 &lt;code&gt;O&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;对于第一个字符不同的字符串该怎么弄呢？&lt;/p&gt;
&lt;p&gt;我们可以定义一个虚拟的&lt;strong&gt;根节点&lt;/strong&gt;。这个节点并没有实际的值，只不过是为了链接第一个字符不同的字符串们的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://image.haoye.plus/Screenshot%20from%202023-11-18%2019-43-22.png&quot; alt=&quot;根节点特写&quot; /&gt;&lt;/p&gt;
&lt;p&gt;为了演示方便，把根节点染成了黄色（其实代码实际用起来并不用做特别区分）。&lt;/p&gt;
&lt;p&gt;把字符串A改为 &lt;code&gt;IF&lt;/code&gt; 后，我们就得到了最终版本的字典树了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://image.haoye.plus/Screenshot%20from%202023-11-18%2019-50-37.png&quot; alt=&quot;高级智慧炫酷充满力量的最终版本字典树+++&quot; /&gt;&lt;/p&gt;
&lt;h1&gt;查询&lt;/h1&gt;
&lt;p&gt;查询很简单。只要在文本串从头到尾遍历，然后在字典树中从上到下遍历就好了。&lt;/p&gt;
&lt;p&gt;如果遍历着遍历着下面没节点了，说明文本串不是任何模式串的前缀。&lt;/p&gt;
&lt;p&gt;如果遍历着遍历着文本串没了，那么此时所在的节点所记录的 &lt;code&gt;num[i]&lt;/code&gt; 就是最终的答案。&lt;/p&gt;
&lt;p&gt;（可以想想为什么会这样。&lt;s&gt;（绝对不是懒得写了）&lt;/s&gt;）&lt;/p&gt;
&lt;h1&gt;代码实践&lt;/h1&gt;
&lt;p&gt;洛谷：&lt;a href=&quot;https://www.luogu.com.cn/problem/P8306&quot;&gt;P8306&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include&amp;lt;bits/stdc++.h&amp;gt; //万能头！！！

using namespace std;

int cnt;
int trie[3000009][70];
int num[3000009];

int c2i(char x){
    if(&apos;a&apos;&amp;lt;=x and x&amp;lt;=&apos;z&apos;)return x - &apos;a&apos; + 1;
    if(&apos;A&apos;&amp;lt;=x and x&amp;lt;=&apos;Z&apos;)return x - &apos;A&apos; + 27;
    if(&apos;0&apos;&amp;lt;=x and x&amp;lt;=&apos;9&apos;)return x - &apos;0&apos; + 53;
}

inline void clearTrie(){
    for(int i=0;i&amp;lt;=cnt;i++){
        for(int j=0;j&amp;lt;70;j++){
            trie[i][j]=0;
        }
        num[i]=0;
    }
    cnt = 0;
}

inline void pushTrie(string x){
    int u=0;
    for(int i=0;i&amp;lt;x.length();i++){
        int c = c2i(x[i]);
        if(!trie[u][c]){
            trie[u][c]=++cnt;
        }
        u=trie[u][c];
        num[u]++;
    }
}

int queryTrie(string x){
    int i,u;
    i=u=0;
    while(i&amp;lt;x.length() &amp;amp;&amp;amp; trie[u][c2i(x[i])]){
        u=trie[u][c2i(x[i])];
        i++;
    }
    if(i == x.length()){
        return num[u];
    }
    return 0;
}

int main(){
    int t;
    cin&amp;gt;&amp;gt;t;
    while(t--){
        clearTrie();
        int n,q;
        cin&amp;gt;&amp;gt;n&amp;gt;&amp;gt;q;
        while(n--){
            string x;
            cin&amp;gt;&amp;gt;x;
            pushTrie(x);
        }
        while(q--){
            string x;
            cin&amp;gt;&amp;gt;x;
            cout&amp;lt;&amp;lt;queryTrie(x)&amp;lt;&amp;lt;endl;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
</content:encoded></item><item><title>拓展kmp (exkmp/ Z function)</title><link>https://blog.haoye.plus/posts/exkmp/</link><guid isPermaLink="true">https://blog.haoye.plus/posts/exkmp/</guid><description>Z function</description><pubDate>Sat, 11 Nov 2023 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;引入&lt;/h1&gt;
&lt;p&gt;KMP算法可以求解出一个模式串在文本串中出现的位置。扩展KMP算法（Z函数）在这个思路上进行了延伸。对于文本串S的每一个后缀（如果文本串S长度为n的话，就指的是 &lt;code&gt;S[i:n]&lt;/code&gt; ，其中 &lt;code&gt;(0&amp;lt;=i&amp;lt;=n-1)&lt;/code&gt; ），找到这个后缀与模式串T的最长公共前缀的长度，存储在 &lt;code&gt;extend[i]&lt;/code&gt; 中。设模式串T长度为m，不难发现，如果我们只看 &lt;code&gt;extend[i] = m&lt;/code&gt; 的情况，相当于在文本串S找出模式串T出现的位置，就和原本的KMP算法一样了。&lt;/p&gt;
&lt;p&gt;扩展KMP算法在国外一般叫做Z函数(Z function)。&lt;/p&gt;
&lt;h1&gt;计算extend数组&lt;/h1&gt;
&lt;p&gt;对于模式串T，我们需要预处理一个数组 &lt;code&gt;next&lt;/code&gt; 。其第i项表示从i开始T的后缀与T的最长公共前缀的长度。&lt;code&gt;next&lt;/code&gt; 数组的求解在下节可以看到，我们先来看看如何用 &lt;code&gt;next&lt;/code&gt; 数组计算出 &lt;code&gt;extend&lt;/code&gt; 数组。&lt;/p&gt;
&lt;p&gt;和之前说的马拉车算法类似，拓展KMP算法也是利用之前的数据对暴力算法进行优化。维护一个当前所到达过的最右边的值 &lt;code&gt;right&lt;/code&gt; 以及所对应的起点 &lt;code&gt;left&lt;/code&gt; （即 &lt;code&gt;left + extend[left] - 1&lt;/code&gt; 的最大值为 &lt;code&gt;right&lt;/code&gt; ）。此时在第 &lt;code&gt;i&lt;/code&gt; 项，默认其前面的 &lt;code&gt;extend[i-1], extend[i-2], ... extend[0]&lt;/code&gt; 都已经更新完毕。&lt;/p&gt;
&lt;p&gt;如果 &lt;code&gt;i &amp;gt; right&lt;/code&gt; ，说明此时第 &lt;code&gt;i&lt;/code&gt; 项还没有更新。此时就用最简单的暴力算法向前推进，并且更新 &lt;code&gt;left&lt;/code&gt; 和 &lt;code&gt;right&lt;/code&gt; 的值。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;left = i;
while((i+extend[i])&amp;lt;s.length() &amp;amp;&amp;amp; (extend[i])&amp;lt;t.length() &amp;amp;&amp;amp; t[extend[i]] == s[i+extend[i]]){//思考题：为什么这里没有+1
	extend[i]++;
}
right = left + extend[i] - 1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果 &lt;code&gt;i &amp;lt;= right&lt;/code&gt; ，就可以利用 &lt;code&gt;left&lt;/code&gt; 和 &lt;code&gt;right&lt;/code&gt; 的值来更新 &lt;code&gt;extend[i]&lt;/code&gt; 了。&lt;/p&gt;
&lt;h2&gt;求解extend数组的最小值&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://image.haoye.plus/Screenshot%20from%202023-11-11%2019-59-13.png&quot; alt=&quot;extend高级图片2&quot; /&gt;&lt;/p&gt;
&lt;p&gt;从上图结合之前学的内容可知， &lt;code&gt;S[left:right+1]&lt;/code&gt; 和 &lt;code&gt;T[0:right-left+1]&lt;/code&gt; 的值是相同的。也就是 &lt;code&gt;S[i:right+1]&lt;/code&gt; 与 &lt;code&gt;T[i-left:right-left+1]&lt;/code&gt; 的值是相同的（图中红色区域和绿色区域是相同的）。&lt;code&gt;next[i-left] = 2&lt;/code&gt; 可以求得 &lt;code&gt;T[0:2] = T[i - left:i - left + 2 + 1]&lt;/code&gt; 也就是黄色区域等于绿色区域的前两个。又因为红色区域等于绿色区域，所以红色区域前两个等于黄色区域。也就是文本串S以第i项开头的后缀与模式串T的最长公共前缀为2，也就是黄色区域的长度 &lt;code&gt;next[i - left]&lt;/code&gt;。进而得到 &lt;code&gt;extend[i] = next[i - left] &lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://image.haoye.plus/Screenshot%20from%202023-11-11%2020-03-04.png&quot; alt=&quot;extend高级图片1&quot; /&gt;&lt;/p&gt;
&lt;p&gt;我们再来看一个例子。&lt;/p&gt;
&lt;p&gt;根据上文所述的方法画出红色，绿色和黄色区域。我们会发现套用上一个结论行不通。因为黄色区域的长度已经超过了红色区域的长度。而我们只能保证红色区域与绿色区域相同，并不能保证红色区域的下一个值和绿色区域的下一个值相同，也就是 &lt;code&gt;S[5]&lt;/code&gt; 和 &lt;code&gt;T[4]&lt;/code&gt; 不能确定是否相同。此时就应该用红色区域的长度作为 &lt;code&gt;extend[i]&lt;/code&gt; 的值。&lt;code&gt;extend[i] = right - i + 1&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;综上，可以得出一个通用式子。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;extend[i] = min(right - i + 1, next[i - left]);
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;拓展&lt;/h2&gt;
&lt;p&gt;如果 &lt;code&gt;i + extend[i] - 1 = right&lt;/code&gt; ，说明本次更新已经到了 &lt;code&gt;s[left:right+1]&lt;/code&gt; 所管辖的尽头，需要对其进行更新。此时就和暴力的时候一样就好了，拓展 &lt;code&gt;extend[i]&lt;/code&gt; 的值并且更新 &lt;code&gt;left&lt;/code&gt; 和 &lt;code&gt;right&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;if(i + extend[i] - 1 &amp;gt; right){
    left = i;
    while((i+extend[i])&amp;lt;s.length() &amp;amp;&amp;amp; (extend[i])&amp;lt;t.length() &amp;amp;&amp;amp; t[extend[i]] == s[i+extend[i]]){//思考题：为什么这里没有+1
        extend[i]++;
    }
    right = i + extend[i] - 1
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1&gt;next 数组&lt;/h1&gt;
&lt;p&gt;其实和上一节很相似，只不过是文本串和模式串都是T而已。这里就直接上代码&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;void calNextt(){
    nextt[0] = t.length(); // 自己和自己的最长公共前缀就是自己本身
    int left,right;
    left = right = 0;
    for(int i=1;i&amp;lt;t.length();i++){
        if(i&amp;lt;=right)
            nextt[i] = min(right-i+1,nextt[i-left]);
        while((i+nextt[i])&amp;lt;t.length() &amp;amp;&amp;amp; t[nextt[i]] == t[i+nextt[i]]){
            nextt[i]++;
        }
        if(i+nextt[i]-1&amp;gt;right){
            left = i;
            right = i+nextt[i]-1;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1&gt;代码实践&lt;/h1&gt;
&lt;p&gt;代码实践：&lt;a href=&quot;https://www.luogu.com.cn/problem/P5410&quot;&gt;洛谷P5410&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;不要忘了用long long!!!!（改了很久的愤怒）&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//LICENSE: GPL v3.0
//https://blog.haoye.plus

#include&amp;lt;iostream&amp;gt;
#include&amp;lt;string&amp;gt;
#define int long long
using namespace std;
string s,t;
int nextt[20000009];//next 为保留字，不能用
int extend[20000009];

void calNextt();
void calExtend();

signed main(){
    cin&amp;gt;&amp;gt;s&amp;gt;&amp;gt;t;

    calNextt();
    //计算答案
    int ans = nextt[0]+1;
    for(int i=1;i&amp;lt;t.length();i++)
        ans = ans xor ((i+1)*(nextt[i]+1));
    cout&amp;lt;&amp;lt;ans&amp;lt;&amp;lt;endl;

    calExtend();
    //计算答案
    ans = extend[0]+1;
    for(int i=1;i&amp;lt;s.length();i++){
        ans = ans xor ((i+1)*(extend[i]+1));
    }
    cout&amp;lt;&amp;lt;ans&amp;lt;&amp;lt;endl;

    return 0;
}

void calNextt(){
    nextt[0] = t.length(); // 自己和自己的最长公共前缀就是自己本身
    int left,right;
    left = right = 0;
    for(int i=1;i&amp;lt;t.length();i++){
        if(i&amp;lt;=right)
            nextt[i] = min(right-i+1,nextt[i-left]);
        while((i+nextt[i])&amp;lt;t.length() &amp;amp;&amp;amp; t[nextt[i]] == t[i+nextt[i]]){
            nextt[i]++;
        }
        if(i+nextt[i]-1&amp;gt;right){
            left = i;
            right = i+nextt[i]-1;
        }
    }
}

void calExtend(){
    extend[0]=0;
    while((extend[0])&amp;lt;s.length() &amp;amp;&amp;amp; (extend[0])&amp;lt;t.length() &amp;amp;&amp;amp; t[extend[0]] == s[extend[0]]){
        extend[0]++;
    }

    int left,right;
    left = 0;
    right = extend[0]-1;
    for(int i=1;i&amp;lt;s.length();i++){
        if(i&amp;lt;=right)
            extend[i] = min(right-i+1,nextt[i-left]);
        while((i+extend[i])&amp;lt;s.length() &amp;amp;&amp;amp; (extend[i])&amp;lt;t.length() &amp;amp;&amp;amp; t[extend[i]] == s[i+extend[i]]){
            extend[i]++;
        }
        if(i+extend[i]-1&amp;gt;right){
            left = i;
            right = i+extend[i]-1;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
</content:encoded></item><item><title>马拉车算法 (Manacher)</title><link>https://blog.haoye.plus/posts/manacher/</link><guid isPermaLink="true">https://blog.haoye.plus/posts/manacher/</guid><description>Manacher Algorithm</description><pubDate>Sun, 05 Nov 2023 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;马拉车算法可以用线性级时间复杂度找出最长回文子串。&lt;/p&gt;
&lt;h1&gt;回文子串&lt;/h1&gt;
&lt;p&gt;考虑这么一种字符串，它正着读和倒着读的内容都一样。我们称这种字符串为回文串。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://image.haoye.plus/Screenshot%20from%202023-11-04%2020-53-11.png&quot; alt=&quot;回文串图片&quot; /&gt;&lt;/p&gt;
&lt;p&gt;接下来的算法目的是在一个字符串的所有子串中找到一个长度最长的回文串，也就是最长回文子串。&lt;/p&gt;
&lt;h1&gt;修改回文串&lt;/h1&gt;
&lt;p&gt;根据回文串长度的奇偶性，可以将它分为两类: 长度为奇数的回文串和长度为偶数的回文串。长度为奇数的回文串中心只有一个元素，而长度为偶数的有两个。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://image.haoye.plus/Screenshot%20from%202023-11-04%2021-07-44.png&quot; alt=&quot;两种回文串&quot; /&gt;&lt;/p&gt;
&lt;p&gt;如果对于这两种回文串进行分类讨论的话，代码会变得更加复杂。我们可以在回文串的左右两边和每个字符之间加上一个特殊字符。这样就只用讨论长度为奇数的回文串。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://image.haoye.plus/Screenshot%20from%202023-11-04%2021-09-42.png&quot; alt=&quot;加了特殊字符的两种回文串&quot; /&gt;&lt;/p&gt;
&lt;h1&gt;O(n^2) 求解&lt;/h1&gt;
&lt;p&gt;很容易想到的一种思路就是暴力枚举。以每一个元素为回文串的中心同时向左右扩散，直到碰到边缘或者左右字符不一致时停止。这被称作中心扩散法。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include&amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
char s[22000010];
int n;
int p[22000010];
int maxx;
inline void algorithm(){
​    for(int i=0;i&amp;lt;n;i++){
​        //扩散
​        while(i - p[i] -1 &amp;gt;= 0 &amp;amp;&amp;amp; i + p[i] + 1 &amp;lt; n &amp;amp;&amp;amp; s[i+p[i]+1] == s[i-p[i]-1]){
​            p[i]++;
​        }
​        //更新最终答案
​        maxx = max(maxx,p[i]);
​    }
}
int main(){
​    //输入并添加特殊字符
​    char c;
​    c=getchar();
​    while(&apos;a&apos;&amp;lt;=c &amp;amp;&amp;amp; c&amp;lt;=&apos;z&apos;){
​        s[n++]=&apos;#&apos;;
​        s[n++]=c;
​        c=getchar();
​    }
​    s[n++]=&apos;#&apos;;
​    maxx = 0;
​    //算法处理
​    algorithm();
​    //输出
​    cout&amp;lt;&amp;lt;maxx&amp;lt;&amp;lt;endl;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;代码会处理添加过特殊字符后的回文串，并记录扩散次数到p数组。&lt;/p&gt;
&lt;p&gt;我们会发现，p数组存储的值正好是对应位置修改前的原始最长回文子串的长度。这样记录好p数组的最大值就可以知道答案了。下面是简短的证明。&lt;/p&gt;
&lt;p&gt;以某一项元素为中心扩散最终左右两边的极限一定是特殊字符。因为不等于的情况永远不是特殊字符（或者碰到边界，不过整个字符串首位就有特殊字符，所以这个情况不难证明），所以最终这个回文串的左右两边的极限肯定都为特殊字符。&lt;/p&gt;
&lt;p&gt;对某一个元素而言，设回文串长度为 &lt;code&gt;2 * l + 1&lt;/code&gt;, 则除去特殊字符的原始字符串长度为 &lt;code&gt;l&lt;/code&gt; ，&lt;code&gt;p[i]&lt;/code&gt; 也等于 &lt;code&gt;l&lt;/code&gt;。所以相等。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://image.haoye.plus/Screenshot%20from%202023-11-06%2008-29-59.png&quot; alt=&quot;p数组证明&quot; /&gt;&lt;/p&gt;
&lt;h1&gt;马拉车算法思路&lt;/h1&gt;
&lt;p&gt;O(n^2)算法的时间复杂度显然不占优势。利用回文串的性质可以对它进行优化&lt;/p&gt;
&lt;p&gt;马拉车算法会记录两个值。一个是目前所有回文子串中最靠右的右端点的下标 &lt;code&gt;max_right&lt;/code&gt; ，另一个是它所对应的回文串中心的下表 &lt;code&gt;center&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;在进行第一个循环时，如果所在的元素 &lt;code&gt;i&lt;/code&gt; 的下标大于 &lt;code&gt;max_right&lt;/code&gt; 说明目前的回文子串无法覆盖到 &lt;code&gt;i&lt;/code&gt; 。此时就只能用到上文的扩散法计算p数组的值并更新 &lt;code&gt;max_right&lt;/code&gt; 与 &lt;code&gt;center&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;可如果 &lt;code&gt;i&lt;/code&gt; 不大于 &lt;code&gt;max_right&lt;/code&gt; ，说明有之前的回文串可以覆盖到 &lt;code&gt;i&lt;/code&gt; 。此时就可以利用回文串的性质进行优化了。&lt;/p&gt;
&lt;p&gt;利用 &lt;code&gt;i&lt;/code&gt; 关于 &lt;code&gt;center&lt;/code&gt; 对称的元素 &lt;code&gt;mirror&lt;/code&gt;，我们可以计算出 &lt;code&gt;p[center]&lt;/code&gt; 的最小值。&lt;/p&gt;
&lt;p&gt;举个例子，考虑以第9项作为center的情况&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://image.haoye.plus/Screenshot%20from%202023-11-04%2021-47-35.png&quot; alt=&quot;例子图片&quot; /&gt;&lt;/p&gt;
&lt;p&gt;对于字符串s，可能会出现下面的三种情况。&lt;/p&gt;
&lt;p&gt;如果 &lt;code&gt;p[mirror] &amp;lt; max_right - i&lt;/code&gt; (这里 &lt;code&gt;max_right - i&lt;/code&gt;  代表着以 &lt;code&gt;center&lt;/code&gt; 为中心的回文串最左端离 &lt;code&gt;mirror&lt;/code&gt; 的距离)，此时 &lt;code&gt;p[i] = p[mirror]&lt;/code&gt;。 因为根据回文串的性质， &lt;code&gt;mirror - p[mirror]&lt;/code&gt; 到 &lt;code&gt;mirror + p[mirror]&lt;/code&gt; 是回文串必然能推出 &lt;code&gt;i - p[mirror]&lt;/code&gt; 到 &lt;code&gt;i + p[mirror]&lt;/code&gt; 子串也是回文串。&lt;code&gt;s[ mirror - p[mirror] - 1 ] != s[ mirror + p[mirror] + 1 ]&lt;/code&gt; 也能推导出 &lt;code&gt;s[ i - p[mirror] - 1 ] != s[ i + p[mirror] + 1 ]&lt;/code&gt;，证明这是最长的回文串。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://image.haoye.plus/Screenshot%20from%202023-11-04%2022-02-32.png&quot; alt=&quot;小于的情况&quot; /&gt;&lt;/p&gt;
&lt;p&gt;如果 &lt;code&gt;p[mirror] = max_right - i&lt;/code&gt; ，同上可知 &lt;code&gt;p[i] = p[mirror]&lt;/code&gt;。 设左端点为 &lt;code&gt;left&lt;/code&gt;，则 &lt;code&gt;s[ mirror-p[mirror]-1 ] != s[ mirror+p[mirror]+1 ]&lt;/code&gt; 不能推导到以 &lt;code&gt;i&lt;/code&gt; 为中心的回文串上。所以此时需要扩散回文串并且更新 &lt;code&gt;max_right&lt;/code&gt; 与 &lt;code&gt;center&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://image.haoye.plus/Screenshot%20from%202023-11-04%2021-58-32.png&quot; alt=&quot;相等的情况&quot; /&gt;&lt;/p&gt;
&lt;p&gt;如果 &lt;code&gt;p[mirror] &amp;gt; max_right - i&lt;/code&gt; ，此时以 &lt;code&gt;mirror&lt;/code&gt; 为中心的回文串已经超出了以 &lt;code&gt;center&lt;/code&gt; 为中心的回文串的范围。通过以 &lt;code&gt;center&lt;/code&gt; 为中心的回文串的性质所推导出来的结论只适用于这个回文串本身的范围。对于他左端点往左和右端点往右的对称性无法保证。设左端点为 &lt;code&gt;left&lt;/code&gt;，可得到 &lt;code&gt;s[ center-p[left]-1 ] != s[ center+p[right]+1]&lt;/code&gt; 。因此此时 &lt;code&gt;p[i] = max_right - i&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://image.haoye.plus/Screenshot%20from%202023-11-04%2022-04-34.png&quot; alt=&quot;大于的情况&quot; /&gt;&lt;/p&gt;
&lt;h1&gt;代码实践&lt;/h1&gt;
&lt;p&gt;模版题: &lt;a href=&quot;https://www.luogu.com.cn/problem/P3805&quot;&gt;P3805 马拉车&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;C++代码&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include&amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
char s[22000010];
int n;
int p[22000010];
int maxx;
inline void manacher(){
​    int center,right;
​    center = -1;
​    right = -1;
​    for(int i=0;i&amp;lt;n;i++){
​        int mirror = center * 2 - i;
​        //如果i在center回文串里面
​        if (i &amp;lt; right){
​            p[i] = min(right - i, p[mirror]);
​        }
​        //扩散
​        while(i - p[i] -1 &amp;gt;= 0 &amp;amp;&amp;amp; i + p[i] + 1 &amp;lt; n &amp;amp;&amp;amp; s[i+p[i]+1] == s[i-p[i]-1]){
​            p[i]++;
​        }
​        //更新right和center
​        if(i+p[i]&amp;gt;right){
​            right = i+p[i];
​            center = i;
​        }
​        //更新最终答案
​        maxx = max(maxx,p[i]);
​    }
}
int main(){
​    //输入并添加特殊字符
​    char c;
​    c=getchar();
​    while(&apos;a&apos;&amp;lt;=c &amp;amp;&amp;amp; c&amp;lt;=&apos;z&apos;){
​        s[n++]=&apos;#&apos;;
​        s[n++]=c;
​        c=getchar();
​    }
​    s[n++]=&apos;#&apos;;
​    maxx = 0;
​    //马拉车
​    manacher();
​    //输出
​    cout&amp;lt;&amp;lt;maxx&amp;lt;&amp;lt;endl;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;封面图来源: &lt;a href=&quot;https://unsplash.com/s/photos/horse&quot;&gt;这里&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</content:encoded></item><item><title>c++语法知识点</title><link>https://blog.haoye.plus/posts/cpp-grammar/</link><guid isPermaLink="true">https://blog.haoye.plus/posts/cpp-grammar/</guid><description>c++ grammar</description><pubDate>Tue, 10 Jan 2023 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;c++程序设计&lt;/h1&gt;
&lt;p&gt;by：小鸭呀&lt;/p&gt;
&lt;p&gt;来源：信息学奥赛一本通+菜鸟教程+oiwiki+我的脑袋&lt;/p&gt;
&lt;p&gt;本文章遵循cc协议，转载请署名&lt;/p&gt;
&lt;p&gt;对于本文章的建议或纠错可以发表评论哦（=^^）&lt;/p&gt;
&lt;p&gt;[TOC]&lt;/p&gt;
&lt;p&gt;（如果支持的话应该上面会显示个目录）&lt;/p&gt;
&lt;h2&gt;让程序不闪退的神奇代码&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;system(&quot;pause&quot;)&lt;/code&gt;版本4.99以前&lt;/p&gt;
&lt;p&gt;getchar() 约等于  system(&quot;pause&quot;)&lt;/p&gt;
&lt;h2&gt;注释&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;//这是一行注释
/*这是有头有尾的注释*/
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;标识符&lt;/h2&gt;
&lt;p&gt;含义：标识实体（变量名，函数名，对象名）&lt;/p&gt;
&lt;p&gt;由大小写字母，下划线和数字0~9组成&lt;/p&gt;
&lt;p&gt;必须以大小写字母和下划线开头&lt;/p&gt;
&lt;h2&gt;运算符&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;啥子运算符&lt;/th&gt;
&lt;th&gt;干啥的&lt;/th&gt;
&lt;th&gt;长啥样&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;算数运算符&lt;/td&gt;
&lt;td&gt;数值运算&lt;/td&gt;
&lt;td&gt;+,-,*,/（如果俩操作数是整数，则为整除）,% (俩操作数必须是整数) ,++,--(七种)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;关系运算符&lt;/td&gt;
&lt;td&gt;比较运算&lt;/td&gt;
&lt;td&gt;&amp;gt;,&amp;lt;,==,&amp;lt;=,&amp;gt;=,!=(六种)     返回布尔值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;逻辑运算符&lt;/td&gt;
&lt;td&gt;逻辑运算&lt;/td&gt;
&lt;td&gt;&amp;amp;&amp;amp;,||,!&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;位操作运算符&lt;/td&gt;
&lt;td&gt;二进制运算&lt;/td&gt;
&lt;td&gt;&amp;amp;,|,~（非),^(异或),&amp;lt;&amp;lt;,&amp;gt;&amp;gt;(六种)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;赋值运算符&lt;/td&gt;
&lt;td&gt;赋值运算&lt;/td&gt;
&lt;td&gt;简单赋值(=),复合算数赋值(+=,-=,*=,/=,%=),复合位运算赋值(&amp;amp;=,|=,^=,&amp;lt;&amp;lt;=,&amp;gt;&amp;gt;=)三类共十一种&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;条件运算符&lt;/td&gt;
&lt;td&gt;条件求值&lt;/td&gt;
&lt;td&gt;条件?结果a:结果b         条件成立，用结果a，否则用结果b&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;逗号运算符&lt;/td&gt;
&lt;td&gt;把若干个表达式组合成一个表达式&lt;/td&gt;
&lt;td&gt;,&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;指针运算符&lt;/td&gt;
&lt;td&gt;取内容，取地址&lt;/td&gt;
&lt;td&gt;取内容(*),取地址(&amp;amp;)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;求字节数运算符&lt;/td&gt;
&lt;td&gt;数据类型所占字节数&lt;/td&gt;
&lt;td&gt;sizeof(数据类型)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;特殊运算符&lt;/td&gt;
&lt;td&gt;玛卡巴卡&lt;/td&gt;
&lt;td&gt;(   )   [  ]   .   -&amp;gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;优先级&lt;/h3&gt;
&lt;p&gt;自己打括号&lt;/p&gt;
&lt;h2&gt;常用库函数&lt;/h2&gt;
&lt;p&gt;依赖cmath库：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;格式&lt;/th&gt;
&lt;th&gt;功能&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;abs(x)/fabs(x)&lt;/td&gt;
&lt;td&gt;绝对值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;exp(x)&lt;/td&gt;
&lt;td&gt;e的x次方&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;floor(x)&lt;/td&gt;
&lt;td&gt;向下取整&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ceil(x)&lt;/td&gt;
&lt;td&gt;向上取整&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;log(x)&lt;/td&gt;
&lt;td&gt;x的自然对数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;pow(x,y)&lt;/td&gt;
&lt;td&gt;x的y次方&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;sqrt(x)&lt;/td&gt;
&lt;td&gt;根号&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;round(x)&lt;/td&gt;
&lt;td&gt;四舍五入&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;sin,cos,tan,acos,asin,atan&lt;/td&gt;
&lt;td&gt;三角函数&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;依赖cstdlib库&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;格式&lt;/th&gt;
&lt;th&gt;功能&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;rand()&lt;/td&gt;
&lt;td&gt;0到RAND-MAX之间随机取一个整数&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;依赖ctime库&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;格式&lt;/th&gt;
&lt;th&gt;功能&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;clock()&lt;/td&gt;
&lt;td&gt;返回程序从开始运行了多少秒&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;依赖algorithm库&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;格式&lt;/th&gt;
&lt;th&gt;功能&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;sort(a,a+n,cmp)&lt;/td&gt;
&lt;td&gt;对长度为n的a数组排序，用cmp方法&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;常量&lt;/h2&gt;
&lt;h3&gt;定义常量&lt;/h3&gt;
&lt;p&gt;#define 变量名 数据&lt;/p&gt;
&lt;p&gt;const 类型 变量名 = 数据;&lt;/p&gt;
&lt;p&gt;常量初始化后不可以改变&lt;/p&gt;
&lt;h3&gt;整型常量&lt;/h3&gt;
&lt;h4&gt;十进制形式&lt;/h4&gt;
&lt;p&gt;如：99，-1&lt;/p&gt;
&lt;h4&gt;八进制形式&lt;/h4&gt;
&lt;p&gt;0开头&lt;/p&gt;
&lt;p&gt;如：012&lt;/p&gt;
&lt;h4&gt;十六进制形式&lt;/h4&gt;
&lt;p&gt;0x开头&lt;/p&gt;
&lt;p&gt;如：0x12A&lt;/p&gt;
&lt;h2&gt;变量&lt;/h2&gt;
&lt;p&gt;int i = 5,j,k(5);    //i，j，k为整型变量，i，k是5，j未知&lt;/p&gt;
&lt;p&gt;a = b = c = 2       等同于    c = 2;b = c;a = b;&lt;/p&gt;
&lt;h2&gt;标准数据类型&lt;/h2&gt;
&lt;h3&gt;整型与实型&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;数据类型&lt;/th&gt;
&lt;th&gt;定义标识符&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;短整型&lt;/td&gt;
&lt;td&gt;short [int]&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;整型&lt;/td&gt;
&lt;td&gt;[long] int&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;长整型&lt;/td&gt;
&lt;td&gt;long [int]&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;超长整型&lt;/td&gt;
&lt;td&gt;long long [int]&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;无符号整型&lt;/td&gt;
&lt;td&gt;unsigned [int]&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;无符号短整型&lt;/td&gt;
&lt;td&gt;unsigned short [int]&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;无符号长整型&lt;/td&gt;
&lt;td&gt;unsigned long [int]&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;无符号超长整型&lt;/td&gt;
&lt;td&gt;unsigned long long&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;单精度实型&lt;/td&gt;
&lt;td&gt;float&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;双精度实型&lt;/td&gt;
&lt;td&gt;double&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;长双精度实型&lt;/td&gt;
&lt;td&gt;long double&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;布尔&lt;/td&gt;
&lt;td&gt;bool&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;枚举类型&lt;/td&gt;
&lt;td&gt;enum&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;注:科学计数法是指数形式的表示方法，&lt;code&gt;十进制小数E整数指数&lt;/code&gt;，例如
$$
1.2\times10^5
$$
就是1.2E+5&lt;/p&gt;
&lt;h3&gt;枚举类型&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;enum 枚举名{
	标识符,标识符,标识符(=整型常数)
} 枚举变量;
//举个栗子
enum food{drink,eat=5}c;
c=drink;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;重定义数据类型&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;typedef int metre;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;转义字符&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;转义字符&lt;/th&gt;
&lt;th&gt;含义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;\b&lt;/td&gt;
&lt;td&gt;退格&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;\r&lt;/td&gt;
&lt;td&gt;不换行的回车&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;\0&lt;/td&gt;
&lt;td&gt;空&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;\n&lt;/td&gt;
&lt;td&gt;回车&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;char类型里+32是大写转小写，-32是小写转大写&lt;/p&gt;
&lt;p&gt;强制类型转换：类型名（被转换的可怜变量）&lt;/p&gt;
&lt;h2&gt;输入输出&lt;/h2&gt;
&lt;p&gt;事先说明：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include&amp;lt;iostream&amp;gt;
#include&amp;lt;cstdio&amp;gt;       //这个章节的内容必须有这些语句
using namespace std;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;cout用小于，cin用大于&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;getchar&lt;/h3&gt;
&lt;p&gt;输入单个字符，无参&lt;/p&gt;
&lt;p&gt;char ch;ch=getchar();&lt;/p&gt;
&lt;h3&gt;putchar&lt;/h3&gt;
&lt;p&gt;输出单个字符，有参&lt;/p&gt;
&lt;p&gt;putchar(66)      根据ASCII码66是字符B，输出B&lt;/p&gt;
&lt;h3&gt;cout&lt;/h3&gt;
&lt;h4&gt;setw&lt;/h4&gt;
&lt;p&gt;要导入iomanip库&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include&amp;lt;iomanip&amp;gt;
cout&amp;lt;&amp;lt;setw(6)&amp;lt;&amp;lt;a;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;setw控制输出的宽度&lt;/p&gt;
&lt;h3&gt;cstdio 库&lt;/h3&gt;
&lt;h4&gt;输入&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;scanf(&quot;%类型&quot;,&amp;amp;变量名)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;格式符：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;格式符&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;d，i&lt;/td&gt;
&lt;td&gt;十进制整数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;u&lt;/td&gt;
&lt;td&gt;无符号十进制整数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;o&lt;/td&gt;
&lt;td&gt;八进制整数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;十六进制整数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;c&lt;/td&gt;
&lt;td&gt;单个字符&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;s&lt;/td&gt;
&lt;td&gt;字符串（非空格开始，空格结束）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;f，e&lt;/td&gt;
&lt;td&gt;实数&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;附加格式说明符：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;附加格式&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;l（L字母）&lt;/td&gt;
&lt;td&gt;长整型或double型&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;h&lt;/td&gt;
&lt;td&gt;短型数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;域宽（一个整数）&lt;/td&gt;
&lt;td&gt;输入多少东西&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;*&lt;/td&gt;
&lt;td&gt;不赋值给变量&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;scanf(&quot;%4d,%4d&quot;,&amp;amp;a,&amp;amp;b);&lt;/p&gt;
&lt;p&gt;cout&amp;lt;&amp;lt;a&amp;lt;&amp;lt;&apos;,&apos;&amp;lt;&amp;lt;b&amp;lt;&amp;lt;endl;&lt;/p&gt;
&lt;p&gt;如果输入的是12345678，则输入为1234,5678&lt;/p&gt;
&lt;h5&gt;scanf有返回值！！！！！&lt;/h5&gt;
&lt;p&gt;返回了成功读取的变量的个数哦！！！&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;while(scanf(&quot;%d&quot;,&amp;amp;x) != EOF){
​	语句
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果成功读取，就执行语句&lt;/p&gt;
&lt;h4&gt;输出&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;printf(格式控制符,输出列表)&lt;/code&gt;&lt;/p&gt;
&lt;h5&gt;格式符&lt;/h5&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;格式符&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;d或i&lt;/td&gt;
&lt;td&gt;十进制整数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;u&lt;/td&gt;
&lt;td&gt;无符号十进制整数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;x或X&lt;/td&gt;
&lt;td&gt;十六进制无符号整数（没有前导符0x）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;o&lt;/td&gt;
&lt;td&gt;八进制无符号整数（没有前导符0）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;c&lt;/td&gt;
&lt;td&gt;字符&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;s&lt;/td&gt;
&lt;td&gt;字符串&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;f&lt;/td&gt;
&lt;td&gt;单、双精度小数，一般6位&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;e或E&lt;/td&gt;
&lt;td&gt;单、双精度以指数形式输出小数，一般6位&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h5&gt;d格式符&lt;/h5&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;参数&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;d&lt;/td&gt;
&lt;td&gt;数字本身长度&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;md&lt;/td&gt;
&lt;td&gt;输出m位&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;-md&lt;/td&gt;
&lt;td&gt;同上，但左对齐&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ld&lt;/td&gt;
&lt;td&gt;长整型&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;mld&lt;/td&gt;
&lt;td&gt;输出m位，左补空格&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0md或0mld&lt;/td&gt;
&lt;td&gt;位数不足m位补0&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h5&gt;f格式符&lt;/h5&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;参数&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;f&lt;/td&gt;
&lt;td&gt;实数格式，小数6位&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;m.nf&lt;/td&gt;
&lt;td&gt;总位数m（含小数点），n位小数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;-m.nf&lt;/td&gt;
&lt;td&gt;同上，左对齐&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h5&gt;s格式符&lt;/h5&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;参数&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;s&lt;/td&gt;
&lt;td&gt;字符串&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ms&lt;/td&gt;
&lt;td&gt;指定宽度m&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;-ms&lt;/td&gt;
&lt;td&gt;同上，左对齐&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;m.ns&lt;/td&gt;
&lt;td&gt;输出m个字符位置，字符数最多n个&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;-m.ns&lt;/td&gt;
&lt;td&gt;同上，左对齐&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;分支&lt;/h2&gt;
&lt;h3&gt;if&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;//基本
if(条件){
	主体;
}

//if...else
if(条件){
	主体1;
} else {
	主体2;
}

//else if
if (条件1) {
	主体1;
} else if (条件2) {
	主体2;
} else if (条件3) {
	主体3;
} else {
	主体4;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;switch&lt;/h3&gt;
&lt;p&gt;case后面要加break哦&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//实例
switch (a){
    case 1:{
        xxx;
        break;
    }
    case 2:{
        xxx;
        break;
    }
    default :{
        xxx;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;循环&lt;/h2&gt;
&lt;h3&gt;for&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;for(初始化;条件;更新){
	循环体;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;while&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;while(条件){
	循环体;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;do...while&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;do {
	循环体;
} while (条件);
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;break 和 continue&lt;/h3&gt;
&lt;p&gt;break跳出循环，continue结束本次循环，前往下次循环&lt;/p&gt;
&lt;h2&gt;数组&lt;/h2&gt;
&lt;p&gt;初始化：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int a[5] = {1,2,3,4,5}   //初始化
int a[5] = {}      //初始化为0
int a[5] = {1,2}   //初始化为1,2,0,0,0
//读取
a[i];
    
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;复制&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;#include&amp;lt;cstring&amp;gt;
memcpy(b,a,sizeof(a))   //a复制到b
memcpy(b,a,sizeof(/*a的数据类型*/)*k)   //a复制k个元素到数组b
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;清零&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;#include&amp;lt;cstring&amp;gt;
int a[5];
memset(a,0/*除了str类型的数组其它只能为0和-1*/,sizeof(a))    //清零
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;二维数组&lt;/h2&gt;
&lt;p&gt;数组的数组&lt;/p&gt;
&lt;h3&gt;格式&lt;/h3&gt;
&lt;p&gt;数据类  数组名  [常量表达式1] [常量表达式2]&lt;/p&gt;
&lt;p&gt;创造后为：常量表达式1行，常量表达式2列&lt;/p&gt;
&lt;h2&gt;程序运行时间&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;#include&amp;lt;ctime&amp;gt;
#include&amp;lt;iostream&amp;gt;
using namespace std;
int main(){
    ...代码
    cout&amp;lt;&amp;lt;clock()/CLOCKS_PER_SEC&amp;lt;&amp;lt;endl;   //输出用时
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;字符类型、字符数组和字符串&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;序号&lt;/th&gt;
&lt;th&gt;函数 &amp;amp; 目的&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;strcpy(s1, s2);&lt;/strong&gt; 复制字符串 s2 到字符串 s1。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;strcat(s1, s2);&lt;/strong&gt; 连接字符串 s2 到字符串 s1 的末尾。连接字符串也可以用 &lt;strong&gt;+&lt;/strong&gt; 号，例如: &lt;code&gt;string str1 = &quot;runoob&quot;; string str2 = &quot;google&quot;; string str = str1 + str2;&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;strlen(s1);&lt;/strong&gt; 返回字符串 s1 的长度。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;strcmp(s1, s2);&lt;/strong&gt; 如果 s1 和 s2 是相同的，则返回 0；如果 s1&amp;lt;s2 则返回值小于 0；如果 s1&amp;gt;s2 则返回值大于 0。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;strchr(s1, ch);&lt;/strong&gt; 返回一个指针，指向字符串 s1 中字符 ch 的第一次出现的位置。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;strstr(s1, s2);&lt;/strong&gt; 返回一个指针，指向字符串 s1 中字符串 s2 的第一次出现的位置。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;字符类型&lt;/h3&gt;
&lt;p&gt;一个字符&lt;/p&gt;
&lt;h3&gt;字符数组&lt;/h3&gt;
&lt;p&gt;装字符的数组&lt;/p&gt;
&lt;h4&gt;输入&lt;/h4&gt;
&lt;p&gt;gets(字符串名称);&lt;/p&gt;
&lt;p&gt;getchar(); //返回字符，回车后才输入&lt;/p&gt;
&lt;p&gt;只能输入一个字符串！！！&lt;/p&gt;
&lt;h4&gt;输出&lt;/h4&gt;
&lt;p&gt;puts(字符串名称);&lt;/p&gt;
&lt;p&gt;putchar(一个字符);&lt;/p&gt;
&lt;p&gt;输入后会自动换行&lt;/p&gt;
&lt;h3&gt;字符串&lt;/h3&gt;
&lt;p&gt;结尾为”\0“，不计入字符串的实际长度&lt;/p&gt;
&lt;h4&gt;字符串的输入输出&lt;/h4&gt;
&lt;p&gt;cin：输入、忽略开头的制表符、换行符、空格。遇到空格或换行停止（不会读取空字符）&lt;/p&gt;
&lt;p&gt;getline：输入、直接读取一行内所有内容，包括空格。格式为&lt;code&gt;getline(cin,字符串变量)&lt;/code&gt;&lt;/p&gt;
&lt;h4&gt;字符串的常用操作&lt;/h4&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;字符串s的操作&lt;/th&gt;
&lt;th&gt;意义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;s.empty()&lt;/td&gt;
&lt;td&gt;s空？返回true否则false&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;s.size()&lt;/td&gt;
&lt;td&gt;s中字符个数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;s[i]&lt;/td&gt;
&lt;td&gt;s中第i个，从0开始&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;s1+s2&lt;/td&gt;
&lt;td&gt;连接s1和s2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;s1=s2&lt;/td&gt;
&lt;td&gt;s1替换为s2的副本&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;s1==s2&lt;/td&gt;
&lt;td&gt;一样true，否则false&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;!=,&amp;lt;,&amp;lt;=,&amp;gt;,&amp;gt;=&lt;/td&gt;
&lt;td&gt;原意，不变&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;s.insert(pos,s2)&lt;/td&gt;
&lt;td&gt;s里面pos位置前插入s2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;s.substr(pos,n)&lt;/td&gt;
&lt;td&gt;返回从pos起的n个字符，返回string&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;s.erase(pos,n)&lt;/td&gt;
&lt;td&gt;删除从pos起的n个字符&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;s.replace(pos,n,s2)&lt;/td&gt;
&lt;td&gt;替换从pos起的n个字符为s2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;s.find(s2,pos)&lt;/td&gt;
&lt;td&gt;寻从pos下标起查找s2第一次出现的位置，找不到返回string::npos&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;s.c_str&lt;/td&gt;
&lt;td&gt;返回与s内容相同的C语言风格的字符串临时指针&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;sscanf(s,&quot;%d&quot;,%N)&lt;/td&gt;
&lt;td&gt;约等于n=int(s)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;sprintf(s,&quot;%d&quot;,N)&lt;/td&gt;
&lt;td&gt;约等于s=str(n)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;s.substr(2,4)&lt;/td&gt;
&lt;td&gt;python中s[2,2+4-1]&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4&gt;字典序&lt;/h4&gt;
&lt;h4&gt;定义&lt;/h4&gt;
&lt;p&gt;从前往后，挨个比较。第i不同，用i比较。如果相等，谁长谁大。一样的话，相等。&lt;/p&gt;
&lt;h4&gt;方法&lt;/h4&gt;
&lt;p&gt;s1.compare(s2)&lt;/p&gt;
&lt;p&gt;如果相等返回0，s1小于s2返回小于0，s1大于s2返回大于0&lt;/p&gt;
&lt;h3&gt;注意&lt;/h3&gt;
&lt;p&gt;字符串和字符数组的区别在于字符串的结尾是&apos;\0&apos;&lt;/p&gt;
&lt;h2&gt;函数&lt;/h2&gt;
&lt;h3&gt;定义&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;void swap(int &amp;amp;a,int &amp;amp;b);//声明
//主体
void swap(int &amp;amp;a,int &amp;amp;b){
    int tmp = a;a = b;b = tmp;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;传址调用&lt;/p&gt;
&lt;h3&gt;匿名函数&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;[闭包](参数){函数体}                 //不指定返回值类型
[闭包](参数) -&amp;gt; 返回值类型 {函数体}   //指定返回值类型
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;闭包&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;[]        //未定义变量.试图在Lambda内使用任何外部变量都是错误的.
[x, &amp;amp;y]   //x 按值捕获, y 按引用捕获.
[&amp;amp;]       //用到的任何外部变量都隐式按引用捕获
[=]       //用到的任何外部变量都隐式按值捕获
[&amp;amp;, x]    //x显式地按值捕获. 其它变量按引用捕获
[=, &amp;amp;z]   //z按引用捕获. 其它变量按值捕获
//来源:https://www.cnblogs.com/pzhfei/archive/2013/01/14/lambda_expression.html
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;文件操作&lt;/h2&gt;
&lt;h3&gt;freopen&lt;/h3&gt;
&lt;p&gt;需要导入cstdio库&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include&amp;lt;cstdio&amp;gt;
freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin);
freopen(&quot;out.txt&quot;,&quot;w&quot;,stdout);
fclose(stdin);fclose(stdout);/*
freopen(&quot;CON&quot;,&quot;r&quot;,stdin);
freopen(&quot;CON&quot;,&quot;w&quot;,stdout);*/
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;fopen&lt;/h3&gt;
&lt;p&gt;fopen版本&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//定义文件指针
FILE *fin,*fout;
fin=fopen(&quot;in.txt&quot;,&quot;rb&quot;);
fout=fopen(&quot;out.txt&quot;,&quot;wb&quot;);
fscanf(fin,&quot;%d&quot;,&amp;amp;temp);
fprintf(fout,&quot;%d\n&quot;,sum);
fclose(fin);fclose(fout);
//切换回标准输入输出
fin=stdin;
fout=stdout;
fscanf(fin,&quot;%d&quot;,&amp;amp;temp);
fprintf(fout,&quot;%d\n&quot;,sum);
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;流&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;#include&amp;lt;cstdio&amp;gt;
#include&amp;lt;fstream&amp;gt;
ifstream fin(&quot;haoye.in&quot;);//定义输入流fin
ofstream fout(&quot;huaiye.out&quot;);//定义输出流fout
int main(){
	//fin输入，fout输出，用法和cin，cout一样
	fin.close();
	fout.close();
	return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;结构体&lt;/h2&gt;
&lt;h3&gt;建立&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;struct 名字 {
	类型名 变量名;
	结构体名字指针 变量名;
} 变量名;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;访问&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;名字.元素
指针-&amp;gt;元素
(*指针).元素
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;指针&lt;/h2&gt;
&lt;h3&gt;定义和运算&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;th&gt;样例&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;定义：类型 *变量名&lt;/td&gt;
&lt;td&gt;int a=10;int *p;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;取地址运算符：&amp;amp;&lt;/td&gt;
&lt;td&gt;p = &amp;amp;a;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;间接运算符：*&lt;/td&gt;
&lt;td&gt;*p = 20;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;指针可以和整数加减，每加一，偏移一个类型的长度&lt;/p&gt;
&lt;h3&gt;初始化&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;方法&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;int *p = NULL;&lt;/td&gt;
&lt;td&gt;声明零指针&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;int a;int *p=&amp;amp;a;&lt;/td&gt;
&lt;td&gt;p初始化为a的地址&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;int *p = new(int);&lt;/td&gt;
&lt;td&gt;申请一个空间给p，*p内容不确定&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;无类型指针&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;void *p;
int a = 10;
p = &amp;amp;a;
cout&amp;lt;&amp;lt;*(int*)p&amp;lt;&amp;lt;endl;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;指针作为函数参数&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;void swap(int *x,int *y){
	int t=*x;
	*x=*y;
	*y=t;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;函数指针&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;int t(int a){
	return a;
}
int main(){
	cout&amp;lt;&amp;lt;t&amp;lt;&amp;lt;endl;
    int (*p)(int a);//定义函数指针变量,不能写成*p(int a)
    p=t;
    cout&amp;lt;&amp;lt;p(5)&amp;lt;&amp;lt;&quot;,&quot;&amp;lt;&amp;lt;(*p)(10)&amp;lt;&amp;lt;endl;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;还有一种定义的方法&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;void t1(){cout&amp;lt;&amp;lt;&quot;1&quot;;}
void t2(){cout&amp;lt;&amp;lt;&quot;2&quot;;}
void t3(){cout&amp;lt;&amp;lt;&quot;3&quot;;}
void t4(){cout&amp;lt;&amp;lt;&quot;4&quot;;}
int sum(int a,int b){return a+b;}
typedef int (*LP)(int,int);
typedef void(*aa)();
int main(){
    aa a[]={t1,t2,t3,t4}
    a[1]();   //输出2
    LP p = sum;
    cout&amp;lt;&amp;lt;p(2,5);     //返回7
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;结构体指针&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;struct a{
    float b;
} *p;//这个可以
a *p;//这个也行
//应用结构体指针变量
p-&amp;gt;b
(*p).score
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;动态&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;int *p = new int(1234);
delete p;
int *p = new int[114514];
delete[] p;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;类（oop）&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;//基本：
class 类名{
	//访问修饰符：private/public/protected
    //变量
    //方法
    返回类型 operator/*跟上要改的运算符号*/(参数){
        阿巴阿巴;
    };
    virtual int haoye(){//调用函数的时候都用子类的，不用这个函数
        ;
    }
};
//派生类
class 好耶 : public/*访问修饰符*/ 坏耶 ,其他父类...{
    阿巴阿巴;
    int haoye(){
        ;
    }
};
&lt;/code&gt;&lt;/pre&gt;
</content:encoded></item></channel></rss>